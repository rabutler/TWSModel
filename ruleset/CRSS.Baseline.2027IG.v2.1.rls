# RiverWare_Ruleset 6.6.3 Patch
# Created 13:21 April 15, 2015
# 
RULESET
AGENDA_ORDER ASCENDING;
DESCRIPTION "Baseline CRSS ruleset<br>$Id: CRSS.rls,v 1.18 2009/02/11 19:04:11 jprairie Exp $";
PRECISION   2;
BEGIN

  POLICY_GROUP   "KNN";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  BEGIN

    RULE                 "Set Peak Yampa Flow";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 August Max DayOfMonth, Current Year";
    BEGIN

      $ "FlamingGorgeEIS.YampaPeakDailyFlow" [@"24:00:00 December Max DayOfMonth, Current Year"] := "MaxItem"( "GetSlotVals"( $ "DailyFlows.YampaDailyDeerlodgeDepleted", "GetDate"( "NumberToDate"( $ "KNN.StartMonth" [] ) CONCAT " 1, " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetYear"( @"24:00:00 December Max DayOfMonth, Current Year" ), "." ) ), "GetDate"( "NumberToDate"( $ "KNN.EndMonth" [] ) CONCAT ( ( GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetDaysInMonth"( "GetDate"( "NumberToDate"( $ "KNN.EndMonth" [] ) CONCAT ", current year" ) ), "." ) ) CONCAT "," ) CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetYear"( @"24:00:00 December Max DayOfMonth, Current Year" ), "." ) ) ) );

    END;

    RULE                 "Re-distribute Daily Demands within Month-Iterative For Second Stage Disagg";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 August Max DayOfMonth, Current Year" AND "MinItem"( "GetSlotVals"( $ "DailyFlows.YampaDailyDeerlodgeDepleted", "GetDate"( "NumberToDate"( $ "KNN.StartMonth" [] ) CONCAT " 1, " CONCAT "Current Year" ), "GetDate"( "NumberToDate"( $ "KNN.EndMonth" [] ) CONCAT ( ( GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetDaysInMonth"( "GetDate"( "NumberToDate"( $ "KNN.EndMonth" [] ) CONCAT ", current year" ) ), "." ) ) CONCAT ", Current Year" ) ) ) ) < $ "KNN.MinDailyFlowAtDeerlodge" [] AND "HasRuleFiredSuccessfully"( "Set Yampa Daily Natural - Second Stage Disagg" ) AND $ "KNN.SecondStageDisaggFlag" [@"24:00:00 December Max DayOfMonth, Current Year"] == 1.00000000;
    BEGIN

      FOREACH (DATETIME month IN "GetDates"( "GetDate"( "NumberToDate"( $ "KNN.StartMonth" [] ) CONCAT ( ( GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetDaysInMonth"( "GetDate"( "NumberToDate"( $ "KNN.StartMonth" [] ) CONCAT ", current year" ) ), "." ) ) CONCAT ", Current Year" ) ), "GetDate"( "NumberToDate"( $ "KNN.EndMonth" [] ) CONCAT ( ( GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetDaysInMonth"( "GetDate"( "NumberToDate"( $ "KNN.EndMonth" [] ) CONCAT ", current year" ) ), "." ) ) CONCAT ", Current Year" ) ), "1 MONTHS" )) DO
          DESCRIPTION          "Check each month.  If there are any daily flows less than the min daily flow<br>then adjust the daily demands, such that the total needed volume to get the <br>daily flows above the min daily flow is distributed evenly amongst the other <br>days in the month";
      IF_STATEMENT ("MinItem"( "GetSlotVals"( $ "DailyFlows.YampaDailyDeerlodgeDepleted", "GetDate"( "GetMonthAsString"( month ) CONCAT " 1, " CONCAT "Current Year" ), "GetDate"( "GetMonthAsString"( month ) CONCAT ( ( GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetDaysInMonth"( "GetDate"( "GetMonthAsString"( month ) CONCAT ", current year" ) ), "." ) ) CONCAT ", Current Year" ) ) ) ) < $ "KNN.MinDailyFlowAtDeerlodge" []) THEN
            IF_STATEMENT (( "SumObjectsAggregatedOverTime"( "UsersAboveDeerlodge", "Total Depletion", "SUM", "ALL", TRUE, month, month ) < ( "SumFlowsToVolume"( $ "DailyFlows.YampaDailyNatural", "GetDate"( "GetMonthAsString"( month ) CONCAT " 1, " CONCAT "Current Year" ), "GetDate"( "GetMonthAsString"( month ) CONCAT ( ( GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetDaysInMonth"( "GetDate"( "GetMonthAsString"( month ) CONCAT ", current year" ) ), "." ) ) CONCAT ", Current Year" ) ) ) - $ "KNN.MinDailyFlowAtDeerlodge" [] * "GetDaysInMonth"( month ) ) COMMENTED_BY "The total monthly volume less the volume needed to maintain the daily min flow<br>is the volume that can be used by demands." ) COMMENTED_BY "If the total monthly depletion above deerlodge, is less than the available volume to<br>demands, then redistributed the demands withing the current month.  If it is greater<br>than the available volume in the current month, then the demands will have to be<br>re-dsitributed to another month.  This is taken care of in another rule of higher priority.") THEN
            FOREACH (LIST index IN "GetNewDailyFlowsIteratively"( month )) DO
            $ "DailyFlows.YampaDailyDeerlodgeDepleted" [GET @INDEX 1.00000000 FROM index] := GET @INDEX 0.00000000 FROM index;

      ENDFOREACH;

      END_IF_STATEMENT;

      END_IF_STATEMENT;

      ENDFOREACH;

    END;

    RULE                 "Set Yampa Daily Depleted Flow at Deerlodge For Second Stage Disagg";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 August Max DayOfMonth, Current Year" AND "HasRuleFiredSuccessfully"( "Set Yampa Daily Natural - Second Stage Disagg" ) AND $ "KNN.SecondStageDisaggFlag" [@"24:00:00 December Max DayOfMonth, Current Year"] == 1.00000000;
    BEGIN

      FOREACH (NUMERIC i IN "GetNumbers"( 0.00000000, ( LENGTH "GetCurrentYearDailyList"(  ) ) - 1.00000000, 1.00000000 )) DO
            $ "DailyFlows.YampaDailyDeerlodgeDepleted" [GET @INDEX i FROM "GetCurrentYearDailyList"(  )] := FOR ( OBJECT user IN "ListSubbasin"( "UsersAboveDeerlodge" ) ) WITH NUMERIC dailyFlow = $ "DailyFlows.YampaDailyNatural" [GET @INDEX i FROM "GetCurrentYearDailyList"(  )] DO
      dailyFlow - user & "Total Depletion" ["GetDate"( "GetMonthAsString"( GET @INDEX i FROM "GetCurrentYearDailyList"(  ) ) CONCAT ", current year" )]
   ENDFOR;

      ENDFOREACH;

    END;

    RULE                 "Set Yampa Daily Natural - Second Stage Disagg";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 August Max DayOfMonth, Current Year" AND "MinItem"( "GetSlotVals"( $ "DailyFlows.YampaDailyDeerlodgeDepleted", @"24:00:00 April 1, Current Year", @"24:00:00 July Max DayOfMonth, Current Year" ) ) < 0.00000000 "cfs";
    BEGIN

      FOREACH (NUMERIC i IN "GetNumbers"( 0.00000000, ( LENGTH "GetCurrentYearDailyList"(  ) ) - 1.00000000, 1.00000000 )) DO
            $ "DailyFlows.YampaDailyNatural" [GET @INDEX i FROM "GetCurrentYearDailyList"(  )] := ( GET @INDEX i FROM "GetSecondStageProportionVector"(  ) ) * "GetCurrentMonthlyNaturalInflow"( GET @INDEX i FROM "GetCurrentYearDailyList"(  ) ) / 24.00000000 "hour";

      ENDFOREACH;

      $ "KNN.SecondStageDisaggFlag" [@"24:00:00 December Max DayOfMonth, Current Year"] := 1.00000000;

    END;

    RULE                 "Re-distribute Daily Demands within Month-Iterative";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 August Max DayOfMonth, Current Year" AND "MinItem"( "GetSlotVals"( $ "DailyFlows.YampaDailyDeerlodgeDepleted", "GetDate"( "NumberToDate"( $ "KNN.StartMonth" [] ) CONCAT " 1, " CONCAT "Current Year" ), "GetDate"( "NumberToDate"( $ "KNN.EndMonth" [] ) CONCAT ( ( GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetDaysInMonth"( "GetDate"( "NumberToDate"( $ "KNN.EndMonth" [] ) CONCAT ", current year" ) ), "." ) ) CONCAT ", Current Year" ) ) ) ) < $ "KNN.MinDailyFlowAtDeerlodge" [] AND $ "KNN.SecondStageDisaggFlag" [@"24:00:00 December Max DayOfMonth, Current Year"] == 0.00000000;
    BEGIN

      FOREACH (DATETIME month IN "GetDates"( "GetDate"( "NumberToDate"( $ "KNN.StartMonth" [] ) CONCAT ( ( GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetDaysInMonth"( "GetDate"( "NumberToDate"( $ "KNN.StartMonth" [] ) CONCAT ", current year" ) ), "." ) ) CONCAT ", Current Year" ) ), "GetDate"( "NumberToDate"( $ "KNN.EndMonth" [] ) CONCAT ( ( GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetDaysInMonth"( "GetDate"( "NumberToDate"( $ "KNN.EndMonth" [] ) CONCAT ", current year" ) ), "." ) ) CONCAT ", Current Year" ) ), "1 MONTHS" )) DO
          DESCRIPTION          "Check each month.  If there are any daily flows less than the min daily flow<br>then adjust the daily demands, such that the total needed volume to get the <br>daily flows above the min daily flow is distributed evenly amongst the other <br>days in the month";
      IF_STATEMENT ("MinItem"( "GetSlotVals"( $ "DailyFlows.YampaDailyDeerlodgeDepleted", "GetDate"( "GetMonthAsString"( month ) CONCAT " 1, " CONCAT "Current Year" ), "GetDate"( "GetMonthAsString"( month ) CONCAT ( ( GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetDaysInMonth"( "GetDate"( "GetMonthAsString"( month ) CONCAT ", current year" ) ), "." ) ) CONCAT ", Current Year" ) ) ) ) < $ "KNN.MinDailyFlowAtDeerlodge" []) THEN
            IF_STATEMENT (( "SumObjectsAggregatedOverTime"( "UsersAboveDeerlodge", "Total Depletion", "SUM", "ALL", TRUE, month, month ) < ( "SumFlowsToVolume"( $ "DailyFlows.YampaDailyNatural", "GetDate"( "GetMonthAsString"( month ) CONCAT " 1, " CONCAT "Current Year" ), "GetDate"( "GetMonthAsString"( month ) CONCAT ( ( GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetDaysInMonth"( "GetDate"( "GetMonthAsString"( month ) CONCAT ", current year" ) ), "." ) ) CONCAT ", Current Year" ) ) ) - $ "KNN.MinDailyFlowAtDeerlodge" [] * "GetDaysInMonth"( month ) ) COMMENTED_BY "The total monthly volume less the volume needed to maintain the daily min flow<br>is the volume that can be used by demands." ) COMMENTED_BY "If the total monthly depletion above deerlodge, is less than the available volume to<br>demands, then redistributed the demands withing the current month.  If it is greater<br>than the available volume in the current month, then the demands will have to be<br>re-dsitributed to another month.  This is taken care of in another rule of higher priority.") THEN
            FOREACH (LIST index IN "GetNewDailyFlowsIteratively"( month )) DO
            $ "DailyFlows.YampaDailyDeerlodgeDepleted" [GET @INDEX 1.00000000 FROM index] := GET @INDEX 0.00000000 FROM index;

      ENDFOREACH;

      END_IF_STATEMENT;

      END_IF_STATEMENT;

      ENDFOREACH;

    END;

    RULE                 "Set Yampa Daily Depleted Flow at Deerlodge";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 August Max DayOfMonth, Current Year";
    BEGIN

      FOREACH (NUMERIC i IN "GetNumbers"( 0.00000000, ( LENGTH "GetCurrentYearDailyList"(  ) ) - 1.00000000, 1.00000000 )) DO
            $ "DailyFlows.YampaDailyDeerlodgeDepleted" [GET @INDEX i FROM "GetCurrentYearDailyList"(  )] := FOR ( OBJECT user IN "ListSubbasin"( "UsersAboveDeerlodge" ) ) WITH NUMERIC dailyFlow = $ "DailyFlows.YampaDailyNatural" [GET @INDEX i FROM "GetCurrentYearDailyList"(  )] DO
      dailyFlow - user & "Total Depletion" ["GetDate"( "GetMonthAsString"( GET @INDEX i FROM "GetCurrentYearDailyList"(  ) ) CONCAT ", current year" )]
   ENDFOR;

      ENDFOREACH;

    END;

    RULE                 "Set Yampa Daily Natural Flow from KNN - primary disagg";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 August Max DayOfMonth, Current Year";
    BEGIN

      FOREACH (NUMERIC i IN "GetNumbers"( 0.00000000, ( LENGTH "GetProportionVector"(  ) ) - 1.00000000, 1.00000000 )) DO
            $ "DailyFlows.YampaDailyNatural" [GET @INDEX i FROM "GetCurrentYearDailyList"(  )] := "VolumeToFlow"( ( GET @INDEX i FROM "GetProportionVector"(  ) ) * "GetSpringVolume"(  ), GET @INDEX i FROM "GetCurrentYearDailyList"(  ) );

      ENDFOREACH;

    DESCRIPTION          "Initialize the flag to 0";
      $ "KNN.SecondStageDisaggFlag" [@"24:00:00 December Max DayOfMonth, Current Year"] := 0.00000000;

    END;

    RULE                 "Set Index Year- Ratios";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 August Max DayOfMonth, Current Year";
    BEGIN

      $ "KNN.IndexYear" [@"24:00:00 December Max DayOfMonth, Current Year"] := WITH NUMERIC seasonalVol = "SumFlowsToVolume"( $ "LittleSnakeRiver.Inflow", @"24:00:00 April Max DayOfMonth, Current Year", @"24:00:00 July Max DayOfMonth, Current Year" ) + "SumFlowsToVolume"( $ "YampaRiver.Inflow", @"24:00:00 April Max DayOfMonth, Current Year", @"24:00:00 July Max DayOfMonth, Current Year" ) DO
      "ChooseIndexYearRatio"( ( "FlowToVolume"( $ "LittleSnakeRiver.Inflow" [@"24:00:00 April Max DayOfMonth, Current Year"], @"24:00:00 April Max DayOfMonth, Current Year" ) + "FlowToVolume"( $ "YampaRiver.Inflow" [@"24:00:00 April Max DayOfMonth, Current Year"], @"24:00:00 April Max DayOfMonth, Current Year" ) ) / seasonalVol, ( "FlowToVolume"( $ "LittleSnakeRiver.Inflow" [@"24:00:00 May Max DayOfMonth, Current Year"], @"24:00:00 May Max DayOfMonth, Current Year" ) + "FlowToVolume"( $ "YampaRiver.Inflow" [@"24:00:00 May Max DayOfMonth, Current Year"], @"24:00:00 May Max DayOfMonth, Current Year" ) ) / seasonalVol, ( "FlowToVolume"( $ "LittleSnakeRiver.Inflow" [@"24:00:00 June Max DayOfMonth, Current Year"], @"24:00:00 June Max DayOfMonth, Current Year" ) + "FlowToVolume"( $ "YampaRiver.Inflow" [@"24:00:00 June Max DayOfMonth, Current Year"], @"24:00:00 June Max DayOfMonth, Current Year" ) ) / seasonalVol, ( "FlowToVolume"( $ "LittleSnakeRiver.Inflow" [@"24:00:00 July Max DayOfMonth, Current Year"], @"24:00:00 July Max DayOfMonth, Current Year" ) + "FlowToVolume"( $ "YampaRiver.Inflow" [@"24:00:00 July Max DayOfMonth, Current Year"], @"24:00:00 July Max DayOfMonth, Current Year" ) ) / seasonalVol )
   ENDWITH;

    END;

    RULE                 "Set Random Number";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( @"t" == @"24:00:00 August Max DayOfMonth, Current Year" ) COMMENTED_BY "Changing the month this rule executes will change the random number generated <br>by the funciton call as the random number index is different for every month/year.<br>";
    BEGIN

      $ "KNN.randomNum" [@"24:00:00 December Max DayOfMonth, Current Year"] := "Random"( "GetRandSeed"(  ), $ "PowellForecastData.Random Index" [], 0.00000000 );

    END;

  END;

  POLICY_GROUP   "Computation Rules";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  BEGIN

    RULE                 "Set Flaming Gorge Flow Components";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    BEGIN

      $ "DailyFlows.FGAvgRampUp" [] := "AveRampUpFlow"(  );

      $ "DailyFlows.FGAvgRampDown" [] := "AveRampDownFlow"(  );

      $ "DailyFlows.FGBaseFlow" [] := "GetFGBaseFlowMagnitude"(  );

      IF_STATEMENT (@"t" == @"24:00:00 July Max DayOfMonth, Current Year") THEN
            $ "DailyFlows.TotalPPCDays" [] := "RoundToNearestDay"( $ "FlamingGorgeData.PPCProportion" [@"24:00:00 May Max DayOfMonth, Current Year"] * 31.00000000 "day" ) + "RoundToNearestDay"( $ "FlamingGorgeData.PPCProportion" [@"24:00:00 June Max DayOfMonth, Current Year"] * 30.00000000 "day" ) + "RoundToNearestDay"( $ "FlamingGorgeData.PPCProportion" [@"24:00:00 July Max DayOfMonth, Current Year"] * 31.00000000 "day" );

            $ "DailyFlows.TotalBypassDays" [] := "RoundToNearestDay"( $ "FlamingGorgeData.BypassProportion" [@"24:00:00 May Max DayOfMonth, Current Year"] * 31.00000000 "day" ) + "RoundToNearestDay"( $ "FlamingGorgeData.BypassProportion" [@"24:00:00 June Max DayOfMonth, Current Year"] * 30.00000000 "day" ) + "RoundToNearestDay"( $ "FlamingGorgeData.BypassProportion" [@"24:00:00 July Max DayOfMonth, Current Year"] * 31.00000000 "day" );

      END_IF_STATEMENT;

    END;

    RULE                 "Compute Compact Annual Volume";
    DESCRIPTION          "This rule fires once a year and computes both Powell's water year release and the Compact Point volume. The Compact Point volume is a sum of the gains from the Paria River and Powell's release over the water year.";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 December 31, Current Year";
    BEGIN

      $ "PowellOperation.Compact Point Volume" [] := "SumFlowsToVolume"( $ "LeeFerryCompactPoint.Gage Outflow", @"24:00:00 October 31, Previous Year", @"24:00:00 September 30, Current Year" );

      $ "PowellOperation.PowellWYRelease" [] := "SumFlowsToVolume"( $ "Powell.Outflow", @"24:00:00 October 31, Previous Year", @"24:00:00 September 30, Current Year" );

    END;

  END;

  POLICY_GROUP   "Havasu Rules";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  BEGIN

    RULE                 "Compute Parker Energy";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    BEGIN

      $ "Lower Basin Energy.Computed Parker Head using Turbine Release" [] := "Compute Head as a Function of Turbine Release"( $ "Havasu.Turbine Release" [] );

      $ "Lower Basin Energy.Computed Parker Energy Using Input Eff" [] := $ "Lower Basin Energy.Parker Efficiency" [0.00000000, 0.00000000] * "FlowToVolume"( $ "Havasu.Turbine Release" [], @"t" ) * $ "Havasu.Operating Head" [] * ( 9789.00000000 "newton" / ( 1.00000000 "m" * 1.00000000 "m" * 1.00000000 "m" ) );

    END;

    RULE                 "Havasu Rule Curve";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT IsNaN $ "Havasu.Outflow" [];
    BEGIN

      $ "Havasu.Outflow" [] := "SolveOutflow"( % "Havasu", $ "Havasu.Inflow" [], "ComputeStorageAtGivenOutflow"( % "Havasu", "ComputeOutflowAtRuleCurveStorage"( % "Havasu" ) ), $ "Havasu.Storage" [@"t - 1"], @"t" );

    END;

  END;

  POLICY_GROUP   "Mohave Rules";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  BEGIN

    RULE                 "Compute Davis Energy";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    BEGIN

      $ "Lower Basin Energy.Computed Davis Energy Using Input Eff" [] := $ "Lower Basin Energy.Davis Efficiency" [0.00000000, 0.00000000] * "FlowToVolume"( $ "Mohave.Turbine Release" [], @"t" ) * "Compute Head as a Function of Turbine Release"( $ "Mohave.Turbine Release" [] ) * ( 9789.00000000 "newton" / ( 1.00000000 "m" * 1.00000000 "m" * 1.00000000 "m" ) );

      $ "Lower Basin Energy.Computed Davis Head using Turbine Release" [] := "Compute Head as a Function of Turbine Release"( $ "Mohave.Turbine Release" [] );

    END;

    RULE                 "Mohave Rule Curve";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT IsNaN "Mohave.Outflow" [];
    BEGIN

      $ "Mohave.Outflow" [] := "SolveOutflow"( % "Mohave", $ "Mohave.Inflow" [], "ComputeStorageAtGivenOutflow"( % "Mohave", "ComputeOutflowAtRuleCurveStorage"( % "Mohave" ) ), $ "Mohave.Storage" [@"t - 1"], @"t" );

    END;

  END;

  POLICY_GROUP   "Mead Rules";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  BEGIN

    RULE                 "Set Mead Outflow During Extreme Low Stochastic";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "ComputeMeadStoragePlusInflowBeforeRelease"(  ) <= "FlowToVolume"( "CurrentDemandBelowMead"(  ), @"t" );
    BEGIN

      PRINT $ "Mead.Inflow" [];

      PRINT $ "SNWPDiversion.Total Depletion Requested" [];

      PRINT $ "Mead.Storage" [@"t - 1"];

      PRINT "CurrentDemandBelowMead"(  );

      $ "Mead.Outflow" [] := "Min"( "Min"( $ "Mead.Inflow" [], "ComputeOutflowAtGivenStorage"( % "Mead", "ComputeStorageAtGivenOutflow"( % "Mead", "CurrentDemandBelowMead"(  ) ) ) COMMENTED_BY "Added in to ensure that the release is not increased beyond the total downstream demands" ), "ComputeOutflowAtGivenStorage_Critical"( % "Mead", 0.00000000 "acre-feet" ) - 1.00000000 "acre-feet/month" );

    END;

    RULE                 "Mead Flood Control";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    BEGIN

      $ "Mead.Outflow" [] := IF ( @"t" <= @"24:00:00 July 31, Current Year" AND $ "Mead.Outflow" [] < "RunoffSeasonRelease"(  ) )
   THEN
      "ComputeMeadSpringReleaseConstrained"(  )
   ELSE
      IF ( @"t" > @"24:00:00 July 31, Current Year" AND $ "Mead.Outflow" [] < "ComputeOutflowAtGivenStorage"( % "Mead", "ComputeTargetStorage"(  ) ) )
      THEN
         "ComputeMeadFallReleaseConstrained"(  )
      ENDIF
   ENDIF;

      $ "MeadFloodControlData.MeadFloodControlFlag" [] := IF ( "MeadInFloodControl"(  ) )
   THEN
      1.00000000
   ENDIF;

      FOREACH (DATETIME date IN @"t" TO @"24:00:00 December 31, Current Year") DO
            $ "Surplus.SurplusFlag" [date] := IF ( "MeadInFloodControl"(  ) )
   THEN
      1.00000000
   ENDIF;

      ENDFOREACH;

      FOREACH (DATETIME date IN @"t" TO @"24:00:00 December 31, Current Year") DO
            $ "Surplus.Flood Control Surplus Flag" [date] := IF ( "MeadInFloodControl"(  ) )
   THEN
      1.00000000
   ENDIF COMMENTED_BY "Need to set this flag for banking";

            $ "Shortage.ShortageFlag" [date] := IF ( "MeadInFloodControl"(  ) )
   THEN
      0.00000000
   ENDIF;

            $ "Nevada ICS.GroundwaterActualMonthlyTake" [date] := IF ( "MeadInFloodControl"(  ) )
   THEN
      0.00000000 "acre-ft"
   ENDIF;

            $ "Nevada ICS.GroundwaterActualMonthlyPut" [date] := IF ( "MeadInFloodControl"(  ) )
   THEN
      0.00000000 "acre-ft"
   ENDIF;

            $ "Nevada ICS.Drop2ActualMonthlyTake" [date] := IF ( "MeadInFloodControl"(  ) )
   THEN
      0.00000000 "acre-ft"
   ENDIF;

            $ "Nevada ICS.AZBankActualMonthlyTake" [date] := IF ( "MeadInFloodControl"(  ) )
   THEN
      0.00000000 "acre-ft"
   ENDIF;

            $ "Nevada ICS.TributaryConsActualMonthlyTake" [date] := IF ( "MeadInFloodControl"(  ) )
   THEN
      0.00000000 "acre-ft"
   ENDIF;

            $ "Nevada ICS.SNGWBankPut" [date] := IF ( "MeadInFloodControl"(  ) )
   THEN
      $ "Nevada ICS.SNGWBankDeposit" [] / 12.00000000
   ENDIF;

            $ "NevadaDesalination.Inflow" [date] := IF ( "MeadInFloodControl"(  ) )
   THEN
      0.00000000 "acre-ft/month"
   ENDIF;

            $ "Arizona ICS.ActualMonthlyPut" [date] := IF ( "MeadInFloodControl"(  ) )
   THEN
      0.00000000 "acre-ft"
   ENDIF;

            $ "Arizona ICS.ActualMonthlyTake" [date] := IF ( "MeadInFloodControl"(  ) )
   THEN
      0.00000000 "acre-ft"
   ENDIF;

            $ "GilaGravityMainCanalPriority1:YumaCountyWUA.Diversion Requested" [date] := IF ( "MeadInFloodControl"(  ) )
   THEN
      $ "ArizonaPriority1Schedules.GilaGravityMainCanalPriority1_YumaCountyWUA_Diversion Requested" [date]
   ENDIF;

            $ "GilaGravityMainCanalPriority1:YumaCountyWUA.Depletion Requested" [date] := IF ( "MeadInFloodControl"(  ) )
   THEN
      $ "ArizonaPriority1Schedules.GilaGravityMainCanalPriority1_YumaCountyWUA_Depletion Requested" [date]
   ENDIF;

            $ "California ICS.ActualMonthlyPut" [date] := IF ( "MeadInFloodControl"(  ) )
   THEN
      0.00000000 "acre-ft"
   ENDIF;

            $ "California ICS.ActualMonthlyTake" [date] := IF ( "MeadInFloodControl"(  ) )
   THEN
      0.00000000 "acre-ft"
   ENDIF;

            $ "California ICS.BrockActualMonthlyTake" [date] := IF ( "MeadInFloodControl"(  ) )
   THEN
      0.00000000 "acre-ft"
   ENDIF;

      ENDFOREACH;

      IF_STATEMENT ("MeadInFloodControl"(  )) THEN
          DESCRIPTION          "set ICMA to zero in Flood Control";
      FOREACH (DATETIME date IN @"t" TO @"24:00:00 December 31, Current Year") DO
            $ "ICMA.ActualMonthlyPut" [date] := 0.00000000 "acre-ft";

            $ "ICMA.ActualMonthlyTake" [date] := 0.00000000 "acre-ft";

            $ "ICMA.ActualMonthlyPulseFlow" [date] := 0.00000000 "acre-ft";

      ENDFOREACH;

      END_IF_STATEMENT;

      FOREACH (STRING diversion IN { "MWD" , "SNWP" , "CAP" , "IID" , "Coachella" , "Mexico" }) DO
            FOREACH (DATETIME date IN @"t" TO @"24:00:00 December 31, Current Year") DO
            FOREACH (STRING user IN "ListLBNormalWaterUsersByProvider"( diversion )) DO
            "GetObject"( diversion CONCAT "Diversion:" CONCAT user ) & "Depletion Requested" [date] := IF ( "MeadInFloodControl"(  ) )
   THEN
      IF ( diversion == "CAP" )
      THEN
         ( "ComputeSurplusDepletion"( diversion, date ) - $ "CAPMinDiversion.Total Depletion Requested" [date] ) * "LBUserToAggRatio"( diversion, user, "Depletion", date )
      ELSE
         IF ( diversion == "Mexico" )
         THEN
            ( ( "ComputeSurplusDepletion"( diversion, date ) - $ "OverDeliveryToMexico.Total Depletion Requested" [date] ) * "LBUserToAggRatio"( diversion, user, "Depletion", date ) ) COMMENTED_BY "Adjust Mexico for OverDelivery object (already set), but during FC, over-delivery counts as Mexico depletion"
         ELSE
            "ComputeSurplusDepletion"( diversion, date ) * "LBUserToAggRatio"( diversion, user, "Depletion", date )
         ENDIF
      ENDIF COMMENTED_BY "CAP minus min diversion b/c min diversion in different object"
   ENDIF;

            "GetObject"( diversion CONCAT "Diversion:" CONCAT user ) & "Diversion Requested" [date] := IF ( "MeadInFloodControl"(  ) )
   THEN
      IF ( diversion == "CAP" )
      THEN
         ( "ComputeSurplusDiversion"( diversion, date ) - $ "CAPMinDiversion.Total Diversion Requested" [date] ) * "LBUserToAggRatio"( diversion, user, "Diversion", date )
      ELSE
         IF ( diversion == "Mexico" )
         THEN
            ( ( "ComputeSurplusDiversion"( diversion, date ) - $ "OverDeliveryToMexico.Total Diversion Requested" [date] ) * "LBUserToAggRatio"( diversion, user, "Diversion", date ) ) COMMENTED_BY "Adjust Mexico for OverDelivery object (already set), but during FC, over-delivery counts as Mexico depletion"
         ELSE
            ( "ComputeSurplusDiversion"( diversion, date ) + IF ( diversion == "MWD" )
            THEN
               $ "MWDSchedule.AnnualReturnFlow" [@"24:00:00 December Max DayOfMonth, Current Year"]
            ELSE
               0.00000000 "acre-ft/month"
            ENDIF ) * "LBUserToAggRatio"( diversion, user, "Diversion", date )
         ENDIF
      ENDIF COMMENTED_BY "CAP minus min diversion b/c min diversion in different object"
   ENDIF;

      ENDFOREACH;

            diversion CONCAT "Schedule.FCSurplusFlag" [date] := IF ( "MeadInFloodControl"(  ) )
   THEN
      1.00000000
   ENDIF;

            IF_STATEMENT ("MeadInFloodControl"(  )) THEN
            "LBSurplus." CONCAT diversion [date] := "ComputeSurplusDepletion"( diversion, date ) - IF ( diversion == "MWD" )
   THEN
      diversion CONCAT "Schedule.Input Depletion Normal Schedule" [date]
   ELSE
      IF ( diversion == "CAP" )
      THEN
         diversion CONCAT "Schedule.Depletion Schedule" [date] + $ "CAPMinDiversion.Total Depletion Requested" [date]
      ELSE
         IF ( diversion == "IID" OR diversion == "Coachella" )
         THEN
            diversion CONCAT "Schedule.Total Depletion Schedule" [date]
         ELSE
            diversion CONCAT "Schedule.Depletion Schedule" [date]
         ENDIF
      ENDIF
   ENDIF;

      END_IF_STATEMENT;

      ENDFOREACH;

      ENDFOREACH;

      FOREACH (DATETIME date IN @"t" TO @"24:00:00 December 31, Current Year") DO
            $ "MWDSchedule.Diversion Schedule" [date] := IF ( "MeadInFloodControl"(  ) )
   THEN
      $ "MWDSchedule.Input Diversion Schedule" [date] + "RemainingMonthlyFallow"( "MWD", date )
   ENDIF COMMENTED_BY "Reset MWD and PVID fallowing to surplus minimum, adjusting for amount of fallowing credits already created by PVID";

            $ "MWDSchedule.Depletion Schedule" [date] := IF ( "MeadInFloodControl"(  ) )
   THEN
      $ "MWDSchedule.Input Depletion Schedule" [date] + "RemainingMonthlyFallow"( "MWD", date )
   ENDIF;

      ENDFOREACH;

    END;

    RULE                 "Set Mead Outflow For Demands";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    BEGIN

      $ "Mead.Outflow" [] := "ComputeOutflowAtGivenStorage"( % "Mead", "ComputeStorageAtGivenOutflow"( % "Mead", "CurrentDemandBelowMead"(  ) ) );

    END;

  END;

  POLICY_GROUP   "Lee Ferry Deficit Rules";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  BEGIN

    RULE                 "Create Lee Ferry Deficit Water";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    BEGIN

      IF_STATEMENT ($ "LeeFerryDeficit.RunningMonthlyDeficit" [] > 0.00000000 "acre-ft") THEN
            $ "LeeFerryDeficitSupply.Inflow" [] := "VolumeToFlow"( $ "LeeFerryDeficit.RunningMonthlyDeficit" [], @"t" );

            $ "Powell.Outflow" [] := $ "Powell.Outflow" [] + "VolumeToFlow"( $ "LeeFerryDeficit.RunningMonthlyDeficit" [], @"t" );

      END_IF_STATEMENT;

    END;

    RULE                 "Running Monthly 10 Year Deficit";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Running Monthly 10 Year Deficit" );
    BEGIN

      $ "LeeFerryDeficit.RunningMonthlyDeficit" [] := "Max"( ( $ "LeeFerryDeficit.10YearCompactAmount" [] - "SumFlowsToVolume"( $ "LeeFerryCompactPoint.Gage Outflow", @"t - 119", @"t" ) ) COMMENTED_BY "The 10 year required amount minus the actual running 10 year amount.<br>A positive number indicates that the compact is violated.  A negative indicates the<br>required 10 year value is exceeded.  Ensure that the value is at minimum 0 to indicate<br>there is no deficit.", 0.00000000 "acre-ft" );

    END;

  END;

  POLICY_GROUP   "Powell Rules";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  BEGIN

    RULE                 "Equalization Post Guidelines";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT @"t" <= @"24:00:00 September 30, Current Year" AND @"t" > @"24:00:00 December 31, 2026" AND IsNaN $ "EqualizationData.EqualFlag" [] AND ( NOT IsNaN "Powell.Storage" [] AND NOT IsNaN $ "EqualizationData.MinObjRelFlag" [] );
    BEGIN

      "Powell.Outflow" [] := IF ( "WaterAvailableInUpperBasin"(  ) >= "602aStorageValue"(  ) )
   THEN
      IF ( $ "EqualizationData.ForecastEOWYSPowell" [] >= $ "EqualizationData.ForecastEOWYSMead" [] )
      THEN
         "SolveOutflow"( % "Powell", $ "Powell.Inflow" [], "PowellComputeStorageAtGivenOutflow"( "ComputePowellRelease"( "CheckEqualizationRelease602a"( "ConvertPowellRelease"( "ComputeEqualizationReleaseList"( $ "EqualizationData.ForecastEOWYSPowell" [], $ "EqualizationData.ForecastEOWYSMead" [] ) ) ) ) ), $ "Powell.Storage" [@"t - 1"], @"t" )
      ENDIF
   ENDIF;

      $ "EqualizationData.EqualFlag" [] := IF ( "WaterAvailableInUpperBasin"(  ) >= "602aStorageValue"(  ) AND $ "EqualizationData.ForecastEOWYSPowell" [] >= $ "EqualizationData.ForecastEOWYSMead" [] )
   THEN
      1.00000000
   ELSE
      0.00000000
   ENDIF;

    END;

    RULE                 "Check Bypass Capacity";
    DESCRIPTION          "If the reservoir is below the power pool, check if the set outflow is greater than the capacity of the bypass tubes.<br>If it is, reset it to the bypass capacity.<br><br>If the reservoir is above the power pool, then the power plant capacity is in play. This is roughly 25,000 cfs, or the maximum ROD release anyway, and the limitations of the bypass tubes do not matter.";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT IsNaN $ "EqualizationData.MinObjRelFlag" [] AND NOT "SpikeMadeThisMonth"(  );
    BEGIN

      $ "Powell.Outflow" [] := IF ( $ "Powell.Storage" [] < "InactiveCapacity"( % "Powell" ) AND $ "Powell.Outflow" [] > "BypassCapacity"( $ "Powell.Pool Elevation" [] ) )
   THEN
      "SolveOutflow"( % "Powell", $ "Powell.Inflow" [], "PowellComputeStorageAtGivenOutflow"( "IterateBypassCapacity"( $ "Powell.Pool Elevation" [] ) ), $ "Powell.Storage" [@"t - 1"], @"t" )
   ENDIF;

      $ "EqualizationData.BypassCapFlag" [] := IF ( IsNaN $ "EqualizationData.BypassCapFlag" [] )
   THEN
      IF ( $ "Powell.Storage" [] < "InactiveCapacity"( % "Powell" ) AND $ "Powell.Outflow" [] > "BypassCapacity"( $ "Powell.Pool Elevation" [] ) )
      THEN
         1.00000000
      ELSE
         0.00000000
      ENDIF
   ENDIF;

    END;

    RULE                 "Add Carryover Equalization Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "ThisRule" );
    BEGIN

      IF_STATEMENT (NaNToZero ( $ "EqualizationData.CarryoverEQFlag" [@"t - 1"] ) == 1.00000000) THEN
            WITH_STATEMENT (NUMERIC addRelease = "Min"( ( "GetMaxReleaseGivenInflow"( % "Powell", $ "Powell.Inflow" [], @"t" ) - $ "Powell.Outflow" [] ) COMMENTED_BY "Amount the current month's release can be increased", "VolumeToFlow"( $ "EqualizationData.CarryoverEQVolume" [@"t - 1"], @"t" ) COMMENTED_BY "Remaining EQ carryover volume" )) DO
            $ "Powell.Outflow" [] := $ "Powell.Outflow" [] + addRelease;

            $ "EqualizationData.CarryoverEQReleaseMade" [] := addRelease;

          DESCRIPTION          "If not able to release all the carryover volume in the current month, update the EQ <br>volume and Flag so this rule will execute again next month.";
      IF_STATEMENT ("FlowToVolume"( addRelease, @"t" ) < $ "EqualizationData.CarryoverEQVolume" [@"t - 1"]) THEN
            $ "EqualizationData.CarryoverEQFlag" [] := 1.00000000;

            $ "EqualizationData.CarryoverEQVolume" [] := $ "EqualizationData.CarryoverEQVolume" [@"t - 1"] - "FlowToVolume"( addRelease, @"t" );

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

    END;

    RULE                 "Equalization Tier";
    DESCRIPTION          "This rule fires monthly January through September and computes the Equalization (EQ) release from Powell, given that the conditions for EQ are met. Note that Powell's previous EOCY storage is compared to the EQ Line. This has the effect of not allowing Powell to bounce in and out of EQ. The new EQ conditions in the Guidelines (release to keep Mead above 1105 so as Powell doesn't go more than 20' below the EQ Line) are performed in the function CheckEqualizationRelease_Mead1105. ";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" <= @"24:00:00 September 30, Current Year" AND IsNaN $ "EqualizationData.EqualBasinStatesFlag" [] AND ( NOT IsNaN "Powell.Storage" [] AND NOT IsNaN $ "EqualizationData.MinObjRelFlag" [] ) AND NOT "SpikeMadeThisMonth"(  );
    BEGIN

      "Powell.Outflow" [] := IF ( "StartYearInEqualization"(  ) COMMENTED_BY "By comparing to Powell's actual storage at beginning of year, EQ is an annual decision" )
   THEN
      "SolveOutflow"( % "Powell", $ "Powell.Inflow" [], "PowellComputeStorageAtGivenOutflow"( "ComputePowellRelease"( "CheckEqualizationRelease_Mead1105"( "ConvertPowellRelease"( "ComputeEqualizationReleaseList"( $ "EqualizationData.ForecastEOWYSPowell" [], $ "EqualizationData.ForecastEOWYSMead" [] ) ) ) ) ), $ "Powell.Storage" [@"t - 1"], @"t" )
   ENDIF;

      $ "EqualizationData.EqualBasinStatesFlag" [] := IF ( "StartYearInEqualization"(  ) )
   THEN
      1.00000000
   ELSE
      0.00000000
   ENDIF;

    DESCRIPTION          "In September, if the monthly releases is less than the computed amount necessary to fully<br>equalize, then set the carryover equalization flag and volume so that the remaining EQ <br>release can be made in the subsequent month.";
      IF_STATEMENT ("StartYearInEqualization"(  ) AND @"t" == @"24:00:00 September Max DayOfMonth, Current Year") THEN
            WITH_STATEMENT (NUMERIC remainingWYRel = "CheckEqualizationRelease_Mead1105"( "ConvertPowellRelease"( "ComputeEqualizationReleaseList"( $ "EqualizationData.ForecastEOWYSPowell" [], $ "EqualizationData.ForecastEOWYSMead" [] ) ) ) + "ForecastPowellRelease"(  )) DO
            WITH_STATEMENT (NUMERIC powellRel = "FlowToVolume"( "SolveOutflow"( % "Powell", $ "Powell.Inflow" [], "PowellComputeStorageAtGivenOutflow"( "ComputePowellRelease"( "CheckEqualizationRelease_Mead1105"( "ConvertPowellRelease"( "ComputeEqualizationReleaseList"( $ "EqualizationData.ForecastEOWYSPowell" [], $ "EqualizationData.ForecastEOWYSMead" [] ) ) ) ) ), $ "Powell.Storage" [@"t - 1"], @"t" ), @"t" )) DO
            IF_STATEMENT ("Floor"( remainingWYRel - powellRel, 100.00000000 "acre-ft" ) COMMENTED_BY "Round the difference down to the nearest 100 acre-ft to keep from setting this when there are only minor differences between the two volume" > 0.00000000 "acre-ft") THEN
            $ "EqualizationData.CarryoverEQFlag" [] := 1.00000000;

            $ "EqualizationData.CarryoverEQVolume" [] := remainingWYRel - powellRel;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

    END;

    RULE                 "Upper Elevation Balancing Tier Jan thru March";
    DESCRIPTION          "This rule fires in January through March and determines if Powell is in the Upper Elevation Balancing Tier (based on previous EOCY storage). If Powell is in this tier and Mead (again, previous EOCY storage) is below the minimum balancing elevation of 1075, Powell makes balancing releases within the min and max of 700 and 900 kaf. If Mead is above 1075, Powell releases 823 maf set in the rule Meet Powell Min Objective Release, which is lower priority and required to fire before this rule.";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" <= @"24:00:00 March 31, Current Year" AND IsNaN $ "Coordinated Operation.UpperLevelBalancingFlag" [] AND ( NOT IsNaN "Powell.Storage" [] AND NOT IsNaN $ "EqualizationData.MinObjRelFlag" [] ) AND NOT "SpikeMadeThisMonth"(  );
    BEGIN

      $ "Powell.Outflow" [] := IF ( "InUpperElevationBalancingTier"(  ) )
   THEN
      IF ( $ "Mead.Storage" [@"24:00:00 December 31, Previous Year"] COMMENTED_BY "Use actual Jan 1 elevation" < "ElevationToStorage"( % "Mead", $ "Coordinated Operation.Hybrid_MeadMinBalancingElevation" [] ) )
      THEN
         "SolveOutflow"( % "Powell", $ "Powell.Inflow" [], "PowellComputeStorageAtGivenOutflow"( "ComputePowellReleaseUpperBalancing"( "ConvertPowellReleaseBalancing"( "ComputeEqualizationReleaseList"( $ "EqualizationData.ForecastEOWYSPowell" [], $ "EqualizationData.ForecastEOWYSMead" [] ) ), "700" COMMENTED_BY "min release", "900" COMMENTED_BY "max release" ) ), $ "Powell.Storage" [@"t - 1"], @"t" ) COMMENTED_BY "Release for Upper Level Balancing if 1) Powell is in the correct elevation tier 2) EQ conditions are not met 3) EQ has not yet trumped 4) Mead is less than 1075 trigger"
      ENDIF
   ENDIF;

      $ "Coordinated Operation.UpperLevelBalancingFlag" [] := IF ( "InUpperElevationBalancingTier"(  ) AND $ "Mead.Storage" [@"24:00:00 December 31, Previous Year"] COMMENTED_BY "Used actual Jan 1 elevation" < "ElevationToStorage"( % "Mead", $ "Coordinated Operation.Hybrid_MeadMinBalancingElevation" [] ) )
   THEN
      1.00000000
   ELSE
      0.00000000
   ENDIF;

    END;

    RULE                 "Upper Elevation Balancing Tier April thru Sept";
    DESCRIPTION          "This rule fires in April through September and makes any required adjustments to Powell's release if Powell began the year in the Upper Elevation Balancing Tier. The decision to switch to the EQ Tier or to increase the release for balancing is based on the April EOWY forecasts. Meaning, the decision made in April stays for the rest of the water year.";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( @"t" <= @"24:00:00 September 30, Current Year" AND @"t" >= @"24:00:00 April 30, Current Year" ) AND IsNaN $ "Coordinated Operation.UpperLevelBalancingFlag" [] AND ( NOT IsNaN "Powell.Storage" [] AND NOT IsNaN $ "EqualizationData.MinObjRelFlag" [] ) AND NOT "SpikeMadeThisMonth"(  );
    BEGIN

      $ "Powell.Outflow" [] := IF ( "InUpperElevationBalancingTier"(  ) )
   THEN
      IF ( ( NOT "EqualizationConditionsMet"(  ) AND IsNaN $ "Coordinated Operation.EQTrumpUpperLevelBalancingFlag" [@"t - 1"] ) COMMENTED_BY "If EQ Trumps in April, release for EQ for the rest of the water year - go to ELSE" )
      THEN
         IF ( $ "EqualizationData.ForecastEOWYSMead" [@"24:00:00 April 30, Current Year"] COMMENTED_BY "If EQ doesn't trump, check April EOWY forecasts for Mead & Powell to see if switch from 823 kaf to Balancing" < "ElevationToStorage"( % "Mead", $ "Coordinated Operation.Hybrid_MeadMinBalancingElevation" [] ) AND $ "EqualizationData.ForecastEOWYSPowell" [@"24:00:00 April 30, Current Year"] > "ElevationToStorage"( % "Powell", $ "Coordinated Operation.Hybrid_PowellUpperTierElevation" [] ) OR $ "Mead.Storage" [@"24:00:00 December 31, Previous Year"] COMMENTED_BY "Use actual Jan 1 elevation" < "ElevationToStorage"( % "Mead", $ "Coordinated Operation.Hybrid_MeadMinBalancingElevation" [] ) )
         THEN
            IF ( $ "Mead.Storage" [@"24:00:00 December 31, Previous Year"] COMMENTED_BY "Use actual Jan 1 elevation" < "ElevationToStorage"( % "Mead", $ "Coordinated Operation.Hybrid_MeadMinBalancingElevation" [] ) )
            THEN
               "SolveOutflow"( % "Powell", $ "Powell.Inflow" [], "PowellComputeStorageAtGivenOutflow"( "ComputePowellReleaseUpperBalancing"( "ConvertPowellReleaseBalancing"( "ComputeEqualizationReleaseList"( $ "EqualizationData.ForecastEOWYSPowell" [], $ "EqualizationData.ForecastEOWYSMead" [] ) ), "700" COMMENTED_BY "min release", "900" COMMENTED_BY "max release" ) ), $ "Powell.Storage" [@"t - 1"], @"t" ) COMMENTED_BY "If Mead began the year less than 1075, release with 700 kaf minimum"
            ELSE
               "SolveOutflow"( % "Powell", $ "Powell.Inflow" [], "PowellComputeStorageAtGivenOutflow"( "ComputePowellReleaseUpperBalancing"( "ConvertPowellReleaseBalancing"( "ComputeEqualizationReleaseList"( $ "EqualizationData.ForecastEOWYSPowell" [], $ "EqualizationData.ForecastEOWYSMead" [] ) ), "823" COMMENTED_BY "min release", "900" COMMENTED_BY "max release" ) ), $ "Powell.Storage" [@"t - 1"], @"t" ) COMMENTED_BY "If Mead is above 1075 at beginning of year but below at April EOWY forecast, release with 823 kaf minimum."
            ENDIF COMMENTED_BY "Release for Balancing if 1) Powell is in the correct elevation tier 2) EQ conditions are not met 3) EQ has not yet trumped 4) Mead is less than 1075 trigger"
         ENDIF
      ELSE
         "SolveOutflow"( % "Powell", $ "Powell.Inflow" [], "PowellComputeStorageAtGivenOutflow"( "ComputePowellRelease"( "CheckEqualizationRelease_Mead1105"( "ConvertPowellRelease"( "ComputeEqualizationReleaseList"( $ "EqualizationData.ForecastEOWYSPowell" [], $ "EqualizationData.ForecastEOWYSMead" [] ) ) ) COMMENTED_BY "Constrain EQ Release to bring Mead to 1105 or Powell 20 ft below the EQ Line." ) ), $ "Powell.Storage" [@"t - 1"], @"t" ) COMMENTED_BY "If Mead below 1105 then EQ release must 1) bring Mead to 1105 2) take Powell 20 ft below the EQ Line or 3) equalize. Whatever occurs first. " COMMENTED_BY "EQ trumps Upper Elevation Balancing if EQ conditions are met OR EQ trumped last month"
      ENDIF
   ENDIF;

      $ "Coordinated Operation.UpperLevelBalancingFlag" [] := IF ( "InUpperElevationBalancingTier"(  ) AND NOT "EqualizationConditionsMet"(  ) AND IsNaN $ "Coordinated Operation.EQTrumpUpperLevelBalancingFlag" [@"t - 1"] AND ( $ "EqualizationData.ForecastEOWYSMead" [@"24:00:00 April 30, Current Year"] COMMENTED_BY "Use April EOWY forecast for Mead & Powell" < "ElevationToStorage"( % "Mead", $ "Coordinated Operation.Hybrid_MeadMinBalancingElevation" [] ) AND $ "EqualizationData.ForecastEOWYSPowell" [@"24:00:00 April 30, Current Year"] > "ElevationToStorage"( % "Powell", $ "Coordinated Operation.Hybrid_PowellUpperTierElevation" [] ) OR $ "Mead.Storage" [@"24:00:00 December 31, Previous Year"] COMMENTED_BY "Use actual Jan 1 elevation" < "ElevationToStorage"( % "Mead", $ "Coordinated Operation.Hybrid_MeadMinBalancingElevation" [] ) ) )
   THEN
      1.00000000
   ELSE
      0.00000000
   ENDIF;

      $ "Coordinated Operation.EQTrumpUpperLevelBalancingFlag" [] := IF ( "InUpperElevationBalancingTier"(  ) AND ( "EqualizationConditionsMet"(  ) OR NOT IsNaN $ "Coordinated Operation.EQTrumpUpperLevelBalancingFlag" [@"t - 1"] ) )
   THEN
      1.00000000
   ENDIF;

      $ "Coordinated Operation.EQTrumpUpperLevelBalancing1105GovFlag" [] := IF ( "InUpperElevationBalancingTier"(  ) AND ( "EqualizationConditionsMet"(  ) OR NOT IsNaN $ "Coordinated Operation.EQTrumpUpperLevelBalancingFlag" [@"t - 1"] ) AND $ "EqualizationData.ForecastEOWYSMead" [@"t"] COMMENTED_BY "Use moving EOWY forecast here for Mead" < "ElevationToStorage"( % "Mead", $ "Coordinated Operation.MeadProtectionElevation" [] ) )
   THEN
      1.00000000
   ENDIF;

    DESCRIPTION          "If in September, and it's a year that switched to EQ in April, then see if we were able to fully <br>equalize.  If not, then set the carryover equalization flag and volume.";
      IF_STATEMENT ("InUpperElevationBalancingTier"(  ) AND @"t" == @"24:00:00 September Max DayOfMonth, Current Year" AND NOT ( NOT "EqualizationConditionsMet"(  ) AND IsNaN $ "Coordinated Operation.EQTrumpUpperLevelBalancingFlag" [@"t - 1"] )) THEN
            WITH_STATEMENT (NUMERIC remainingWYRel = "CheckEqualizationRelease_Mead1105"( "ConvertPowellRelease"( "ComputeEqualizationReleaseList"( $ "EqualizationData.ForecastEOWYSPowell" [], $ "EqualizationData.ForecastEOWYSMead" [] ) ) ) + "ForecastPowellRelease"(  )) DO
            WITH_STATEMENT (NUMERIC powellRel = "FlowToVolume"( "SolveOutflow"( % "Powell", $ "Powell.Inflow" [], "PowellComputeStorageAtGivenOutflow"( "ComputePowellRelease"( "CheckEqualizationRelease_Mead1105"( "ConvertPowellRelease"( "ComputeEqualizationReleaseList"( $ "EqualizationData.ForecastEOWYSPowell" [], $ "EqualizationData.ForecastEOWYSMead" [] ) ) ) ) ), $ "Powell.Storage" [@"t - 1"], @"t" ), @"t" )) DO
            IF_STATEMENT (( "Floor"( remainingWYRel - powellRel, 100.00000000 "acre-ft" ) > 0.00000000 "acre-ft" ) COMMENTED_BY "Round the difference down to the nearest 100 acre-ft to keep from setting this when there are only minor differences between the two volume") THEN
            $ "EqualizationData.CarryoverEQFlag" [] := 1.00000000;

            $ "EqualizationData.CarryoverEQVolume" [] := remainingWYRel - powellRel;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

    END;

    RULE                 "Mid Elevation Release Tier";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT IsNaN $ "Coordinated Operation.ReducedReleaseFlag" [] AND ( NOT IsNaN "Powell.Storage" [] AND NOT IsNaN $ "EqualizationData.MinObjRelFlag" [] ) AND NOT "SpikeMadeThisMonth"(  );
    BEGIN

      $ "Powell.Outflow" [] := IF ( @"t" <= @"September" )
   THEN
      IF ( "InMidElevationReleaseTier"(  ) AND $ "Mead.Storage" [@"24:00:00 December 31, Previous Year"] >= "ElevationToStorage"( % "Mead", $ "Coordinated Operation.Hybrid_Mead823Trigger" [] ) )
      THEN
         "SolveOutflow"( % "Powell", $ "Powell.Inflow" [], "PowellComputeStorageAtGivenOutflow"( "PowellReducedRelforCurrentMonth"( "748" ) ), $ "Powell.Storage" [@"t - 1"], @"t" )
      ENDIF COMMENTED_BY "Compare Powell and Mead previous EOCYS instead of forecasted EOWYS"
   ELSE
      IF ( $ "Powell.Pool Elevation" [@"24:00:00 September 30, Current Year"] < $ "Coordinated Operation.Hybrid_PowellUpperTierElevation" [] AND $ "Powell.Pool Elevation" [@"24:00:00 September 30, Current Year"] >= $ "Coordinated Operation.Hybrid_PowellLowerTierElevation" [] AND $ "Mead.Pool Elevation" [@"24:00:00 September 30, Current Year"] >= $ "Coordinated Operation.Hybrid_Mead823Trigger" [] )
      THEN
         "SolveOutflow"( % "Powell", $ "Powell.Inflow" [], "PowellComputeStorageAtGivenOutflow"( "PowellReducedRelforCurrentMonth"( "748" ) ), $ "Powell.Storage" [@"t - 1"], @"t" )
      ENDIF
   ENDIF;

      $ "Coordinated Operation.ReducedReleaseFlag" [] := IF ( @"t" <= @"September" )
   THEN
      IF ( "InMidElevationReleaseTier"(  ) AND $ "Mead.Storage" [@"24:00:00 December 31, Previous Year"] >= "ElevationToStorage"( % "Mead", $ "Coordinated Operation.Hybrid_Mead823Trigger" [] ) )
      THEN
         1.00000000
      ELSE
         0.00000000
      ENDIF
   ELSE
      IF ( $ "Powell.Pool Elevation" [@"24:00:00 September 30, Current Year"] < $ "Coordinated Operation.Hybrid_PowellUpperTierElevation" [] AND $ "Powell.Pool Elevation" [@"24:00:00 September 30, Current Year"] >= $ "Coordinated Operation.Hybrid_PowellLowerTierElevation" [] AND $ "Mead.Pool Elevation" [@"24:00:00 September 30, Current Year"] >= $ "Coordinated Operation.Hybrid_Mead823Trigger" [] )
      THEN
         1.00000000
      ELSE
         0.00000000
      ENDIF
   ENDIF;

    END;

    RULE                 "Lower Elevation Balancing Tier";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" <= @"24:00:00 September 30, Current Year" AND IsNaN $ "Coordinated Operation.LowerLevelBalancingFlag" [] AND ( NOT IsNaN "Powell.Storage" [] AND NOT IsNaN $ "EqualizationData.MinObjRelFlag" [] ) AND NOT "SpikeMadeThisMonth"(  );
    BEGIN

      $ "Powell.Outflow" [] := IF ( "InLowerElevationBalancingTier"(  ) )
   THEN
      "SolveOutflow"( % "Powell", $ "Powell.Inflow" [], "PowellComputeStorageAtGivenOutflow"( "ComputePowellReleaseLowerBalancing"( "ConvertPowellReleaseBalancing"( "ComputeEqualizationReleaseList"( $ "EqualizationData.ForecastEOWYSPowell" [], $ "EqualizationData.ForecastEOWYSMead" [] ) ) COMMENTED_BY "No additional check required because balancing releases made until dead pool", "700" COMMENTED_BY "min release", "950" COMMENTED_BY "max release" ) ), $ "Powell.Storage" [@"t - 1"], @"t" )
   ENDIF COMMENTED_BY "Compare Powell and Mead previous EOCYS instead of forecasted EOWYS";

      $ "Coordinated Operation.LowerLevelBalancingFlag" [] := IF ( "InLowerElevationBalancingTier"(  ) )
   THEN
      1.00000000
   ELSE
      0.00000000
   ENDIF;

    END;

    RULE                 "Meet Powell Min Objective Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT IsNaN $ "EqualizationData.MinObjRelFlag" [] AND NOT IsNaN $ "Powell.Outflow" [] AND NOT "SpikeMadeThisMonth"(  );
    BEGIN

      "Powell.Outflow" [] := IF ( $ "Powell.Outflow" [] < "PowellMinObjRelforCurrentMonth"(  ) )
   THEN
      "SolveOutflow"( % "Powell", $ "Powell.Inflow" [], "PowellComputeStorageAtGivenOutflow"( "PowellMinObjRelforCurrentMonth"(  ) ), $ "Powell.Storage" [@"t - 1"], @"t" )
   ENDIF;

      $ "EqualizationData.MinObjRelFlag" [] := IF ( $ "Powell.Outflow" [] < "PowellMinObjRelforCurrentMonth"(  ) )
   THEN
      1.00000000
   ELSE
      0.00000000
   ENDIF;

    END;

    RULE                 "Powell Limit Outflow Rule";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" >= @"24:00:00 July Max DayOfMonth, Current Year" AND NOT "SpikeMadeThisMonth"(  );
    BEGIN

      $ "Powell.Outflow" [] := IF ( "PowellComputeStorageAtGivenOutflow"( 25000.00000000 "cfs" ) < 23822000.00000000 "acre-feet" AND $ "Powell.Outflow" [] > 25000.00000000 "cfs" )
   THEN
      "SolveOutflow"( % "Powell", $ "Powell.Inflow" [], "PowellComputeStorageAtGivenOutflow"( 25000.00000000 "cfs" ), $ "Powell.Storage" [@"t - 1"], @"t" )
   ENDIF;

    END;

    RULE                 "Powell Smooth July Operation Rule";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 July Max DayOfMonth, Current Year" AND NOT "SpikeMadeThisMonth"(  );
    BEGIN

      $ "Powell.Outflow" [] := IF ( $ "Powell.Storage" [] > 23000000.00000000 "acre-feet" AND $ "Powell.Outflow" [] < 1000000.00000000 "acre-feet/month" )
   THEN
      "SolveOutflow"( % "Powell", $ "Powell.Inflow" [], "PowellComputeStorageAtGivenOutflow"( 1000000.00000000 "acre-feet/month" ), $ "Powell.Storage" [@"t - 1"], @"t" )
   ENDIF;

    END;

    RULE                 "Powell Spike Flow Rule";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" <= @"24:00:00 July 31, Current Year" AND IsNaN $ "Powell Spike Flow Data.Spike Flow Flag" [] AND NOT IsNaN "Powell.Storage" [] AND NOT "SpikeAlreadyMade"(  );
    BEGIN

      $ "Powell.Bypass" [] := IF ( "CheckSpikeFlowCriteria"(  ) )
   THEN
      "VolumeToFlow"( $ "Powell Spike Flow Data.Additional Bypass Volume" [0.00000000, 0.00000000], @"t" )
   ENDIF;

      $ "Powell.Outflow" [] := IF ( "CheckSpikeFlowCriteria"(  ) )
   THEN
      IF ( $ "Powell.Spill" [] > 0.00000000 "acre-feet/month" )
      THEN
         "Max"( $ "Powell.Outflow" [], "VolumeToFlow"( $ "Powell Spike Flow Data.Additional Bypass Volume" [0.00000000, 0.00000000], @"t" ) )
      ELSE
         "SolveOutflow"( % "Powell", $ "Powell.Inflow" [], "PowellComputeStorageAtGivenOutflow"( "PowellMinSpikeFlowOutflow"(  ) + "VolumeToFlow"( $ "Powell Spike Flow Data.Additional Bypass Volume" [0.00000000, 0.00000000], @"t" ) ), $ "Powell.Storage" [@"t - 1"], @"t" )
      ENDIF
   ENDIF;

      $ "Powell Spike Flow Data.Spike Flow Flag" [] := IF ( "CheckSpikeFlowCriteria"(  ) )
   THEN
      1.00000000
   ELSE
      0.00000000
   ENDIF;

    END;

    RULE                 "Powell Operations Rule";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    BEGIN

      $ "Powell.Outflow" [] := IF ( @"t" <= @"24:00:00 July Max DayOfMonth, Current Year" AND @"t" >= @"24:00:00 January Max DayOfMonth, Current Year" )
   THEN
      "SolveOutflow"( % "Powell", $ "Powell.Inflow" [], "PowellRunoffSeasonStorage"(  ), $ "Powell.Storage" [@"t - 1"], @"t" )
   ELSE
      "SolveOutflow"( % "Powell", $ "Powell.Inflow" [], "PowellFallSeasonStorage"(  ), $ "Powell.Storage" [@"t - 1"], @"t" )
   ENDIF;

    END;

    RULE                 "Sum Powell Inflow Fall";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 December 31, Current Year";
    BEGIN

      FOREACH (DATETIME date IN @"24:00:00 August 31, Current Year" TO @"24:00:00 December 31, Current Year") DO
            $ "PowellForecastData.Powell Inflow Volume" [date] := "SumFlowsToVolume"( $ "Powell.Inflow", date, @"24:00:00 December 31, Current Year" );

      ENDFOREACH;

    END;

    RULE                 "Sum Powell Inflow Spring";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 July 31, Current Year";
    BEGIN

      FOREACH (DATETIME date IN @"24:00:00 January 31, Current Year" TO @"24:00:00 July 31, Current Year") DO
            $ "PowellForecastData.Powell Inflow Volume" [date] := "SumFlowsToVolume"( $ "Powell.Inflow", date, @"24:00:00 July 31, Current Year" );

      ENDFOREACH;

    END;

    RULE                 "Estimate Upper Basin Storage";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT IsNaN $ "EqualizationData.AvailableWater" [] AND @"t" <= @"24:00:00 September 30, Current Year";
    BEGIN

      $ "EqualizationData.AvailableWater" [] := "SumUpperBasinStorage"(  );

    END;

    RULE                 "EOWYStorageForecasts";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT IsNaN $ "EqualizationData.ForecastEOWYSPowell" [];
    BEGIN

      $ "EqualizationData.ForecastEOWYSPowell" [] := IF ( @"t" >= @"October" )
   THEN
      0.00000000 "acre-ft"
   ELSE
      "EOWYStorage"( % "Powell", "ForecastPowellRelease"(  ), "ForecastMeadRelease"(  ) )
   ENDIF;

      $ "EqualizationData.ForecastEOWYSMead" [] := IF ( @"t" >= @"October" )
   THEN
      0.00000000 "acre-ft"
   ELSE
      "EOWYStorage"( % "Mead", "ForecastPowellRelease"(  ), "ForecastMeadRelease"(  ) )
   ENDIF;

    END;

    RULE                 "Powell Runoff Forecast";
    DESCRIPTION          "This rule was added to compute and store the forecasts for inflows into Lake Powell.  These computations<br>are done for Mead's inflow forecast, so we should clean that up eventually.<br><br>It assumes that the forecast error has been computed previously by the Powell Forecast Error rule <br>and stored on the data/slot  MeadFloodControlData.PowellForecastError";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" <= @"24:00:00 July Max DayOfMonth, Current Year" AND @"t" >= @"24:00:00 January Max DayOfMonth, Current Year";
    BEGIN

      $ "PowellForecastData.Natural Inflow with Error" [] := $ "Qsum.Powell" [] - $ "MeadFloodControlData.PowellForecastError" [] * 1000000.00000000 "acre-feet";

      $ "PowellForecastData.Unreg Inflow with Error" [] := $ "Qsum.Powell" [] - $ "MeadFloodControlData.PowellForecastError" [] * 1000000.00000000 "acre-feet" - "UBDepletionsRange"( @"t", @"24:00:00 July Max DayOfMonth, Current Year" );

      $ "PowellForecastData.Reg Inflow with Error" [] := ( $ "Qsum.Powell" [] - $ "MeadFloodControlData.PowellForecastError" [] * 1000000.00000000 "acre-feet" ) - ( ( "UBDepletionsRange"( @"t", @"24:00:00 July Max DayOfMonth, Current Year" ) + "UBEffectiveStorage"(  ) ) * "Min"( 1.00000000, ( $ "Qsum.Powell" [] - $ "PowellForecastData.forecastError" [] COMMENTED_BY "same as MeadFloodControlData.PowellForecastError * 1 MAF" ) COMMENTED_BY "Natural Inflow w/error" / $ "HistoricalNaturalFlow.AboveLeesFerry_AvgHistMonth2JulyQSum" [] COMMENTED_BY "The historical avg. natural flow above Lees Ferry for the current month through July (Qsum)" ) );

    END;

    RULE                 "Powell Forecast Error";
    DESCRIPTION          "Brad Vickers, Wave Engineering Inc.<br>January, 1999<br><br>This rule checks to see if the PowellForecastError slot on the MeadFloodControlData object has been set, if it has not and the month is not June (because June has some special limits) then<br>the forecast error for Powell is computed with the ComputeForecastError function.  The first part of the IF statement in the rule limits June's computed forecast error to one half of <br>May's forecast error. This check was performed in the originall CRSS.  Ideally I believe there should be limits on every month to ensure that the forecast error is within the range of historical <br>forecast error.  This becomes a problem with the random component of how the forecast error is derived.  See the comments on the ComputeForecastError function for further information on<br>how the forecast error is computed. <br><br>NOTE the print statement in this rule.  this calls the resetRanDev function which rewinds the file of random numbers to the hydrology start date that is input<br>by the user on the MeadFloodControlData.HydrologyStartYear table slot.  This function is only called at the first of the model run.  It is used with a print statement because it has to be in a rule <br>rather than a function and there are no slots set with it.<br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT IsNaN $ "MeadFloodControlData.PowellForecastError" [];
    BEGIN

      $ "MeadFloodControlData.PowellForecastError" [] := "ComputePowellForecastError"(  );

      $ "PowellForecastData.forecastError" [] := "ComputePowellForecastError"(  ) * 1000000.00000000 "acre-feet";

      $ "PowellForecastData.random" [] := "SetRandomDeviation"(  );

    END;

    RULE                 "Compute 70R Assurance Level Surplus Volume";
    DESCRIPTION          "This rule fires at the beginning of the year and sets the 70R surplus volume. This is the estimated end-of-year volume of water in excess of the system space requirement assuming a 70th percentile runoff, a 7.5 maf Lower Basin delivery, the Upper Basin scheduled use and the current Powell and Mead volumes. If this volume is greater than 0, a 70R or Quantified Surplus is declared in the Surplus Rules: 70R Assurance Level Surplus and 7 State Plan Level 1. ";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January 31, Current Year" AND IsNaN $ "Surplus.SurplusRelease" [];
    BEGIN

      $ "Surplus.SurplusRelease" [] := ( ( $ "Powell.Storage" [@"t - 1"] + $ "Mead.Storage" [@"t - 1"] - "SurplusMaxStorage"(  ) ) - "SumPreviousYearICSCredits"(  ) COMMENTED_BY "Beginning total ICS balance is not included in 70R determination." ) * ( 1.00000000 + ( $ "Mead.Bank Storage Coefficient" [0.00000000, 0.00000000] + $ "Powell.Bank Storage Coefficient" [0.00000000, 0.00000000] ) / 2.00000000 ) + "ComputeInflowAtProbability"(  ) - "SumUBDemands"(  ) - "SumLBDemands"(  );

    END;

    RULE                 "Compute 602a Storage";
    DESCRIPTION          "This rule fires once a year and sets the 602a storage. Although this solves for each year in the run duration, the value is only used while the Guidelines are in effect, through 2026.";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January 31, Current Year" AND IsNaN $ "EqualizationData.value602a" [@"24:00:00 December 31, Current Year"];
    BEGIN

      $ "EqualizationData.value602a" [@"24:00:00 December 31, Current Year"] := "602aStorage"(  );

    END;

  END;

  POLICY_GROUP   "ICS and Other Project Water Rules";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  BEGIN

    RULE                 "Set ICMA Slots to Zero";
    DESCRIPTION          "Unassigned ICS refers to users of ICS other than the Basin States. Unassigned ICS was used to model the additional activity beyond 2.1 maf in the Preferred Alternative. This rule sets the Unassigned ICS put and take schedules to 0 every year. If this rule is active, a maximum ICS mechanism of 2.1 maf (the limit adopted in the 2007 ROD) is being modeled. This rule should be turned off if modeling activity beyond 2.1 maf.";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January 31, Current Year";
    BEGIN

      FOREACH (DATETIME date IN @"t" TO @"24:00:00 December 31, Current Year") DO
            $ "ICMA.MXCons_ActualMonthlyPut" [date] := 0.00000000 "acre-ft";

            $ "ICMA.MXCons_ActualMonthlyTake" [date] := 0.00000000 "acre-ft";

            $ "ICMA.MXDesal_ActualMonthlyPut" [date] := 0.00000000 "acre-ft";

            $ "ICMA.MXDesal_ActualMonthlyTake" [date] := 0.00000000 "acre-ft";

            $ "ICMA.MXPulse_ActualMonthlyTake" [date] := 0.00000000 "acre-ft";

            $ "ICMA.USCons_ActualMonthlyPut" [date] := 0.00000000 "acre-ft";

            $ "ICMA.USCons_ActualMonthlyTake" [date] := 0.00000000 "acre-ft";

            $ "ICMA.USDesal_ActualMonthlyPut" [date] := 0.00000000 "acre-ft";

            $ "ICMA.USDesal_ActualMonthlyTake" [date] := 0.00000000 "acre-ft";

            $ "ICMA.USPulse_ActualMonthlyTake" [date] := 0.00000000 "acre-ft";

      ENDFOREACH;

    END;

    RULE                 "Adjust User for California ICS Put";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January 31, Current Year" AND ( NOT IsNaN $ "Surplus.SurplusFlag" [] OR NOT IsNaN $ "Mead Bank.Normal Year" [@"24:00:00 December 31, Current Year"] ) AND @"t" <= "NumberToDate"( $ "Mead Bank.LastYearForPuts" [@"24:00:00 December 31, Current Year"] );
    BEGIN

      FOREACH (DATETIME date IN @"t" TO @"t + 11") DO
            $ "IIDDiversion.Total Diversion Requested" [date] := $ "IIDDiversion.Total Diversion Requested" [date] - "VolumeToFlow"( "MWDExchangeWithIID"( date ), date );

            $ "IIDDiversion.Total Depletion Requested" [date] := $ "IIDDiversion.Total Depletion Requested" [date] - "VolumeToFlow"( "MWDExchangeWithIID"( date ), date );

      ENDFOREACH;

    END;

    RULE                 "Adjust User for Arizona ICS Put";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January 31, Current Year" AND ( NOT IsNaN $ "Surplus.SurplusFlag" [] OR NOT IsNaN $ "Shortage.ShortageFlag" [] OR NOT IsNaN $ "Mead Bank.Normal Year" [@"24:00:00 December 31, Current Year"] ) AND @"t" <= "NumberToDate"( $ "Mead Bank.LastYearForPuts" [@"24:00:00 December 31, Current Year"] );
    BEGIN

      FOREACH (DATETIME date IN @"t" TO @"t + 11") DO
            $ "GilaGravityMainCanalPriority1:YumaCountyWUA.Diversion Requested" [date] := $ "ArizonaPriority1Schedules.GilaGravityMainCanalPriority1_YumaCountyWUA_Diversion Requested" [date] - "VolumeToFlow"( "CAPExchangeWithYumaCountyWUA"( date ), date );

            $ "GilaGravityMainCanalPriority1:YumaCountyWUA.Depletion Requested" [date] := $ "ArizonaPriority1Schedules.GilaGravityMainCanalPriority1_YumaCountyWUA_Depletion Requested" [date] - "VolumeToFlow"( "CAPExchangeWithYumaCountyWUA"( date ), date );

      ENDFOREACH;

    END;

    RULE                 "Adjust Gains for Nevada ICS Put and Other";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January 31, Current Year" AND IsNaN $ "NevadaTributaryConservation.Inflow" [@"24:00:00 January 31, Current Year"];
    BEGIN

      FOREACH (DATETIME date IN @"t" TO @"t + 11") DO
            $ "NevadaTributaryConservation.Inflow" [date] := "VolumeToFlow"( ( $ "Nevada ICS.TributaryConsAnnualPut" [@"24:00:00 December 31, Current Year"] / 12.00000000 ) COMMENTED_BY "Put always occurs regardless of bank balance. Use schedule and not ActualMonthly", date );

            $ "NevadaGroundwater.Inflow" [date] := "VolumeToFlow"( ( $ "Nevada ICS.GroundwaterActualMonthlyPut" [date] / "SystemTaxAdjustment"(  ) ) COMMENTED_BY "Need to add system tax back in for real water", date );

            $ "NevadaDesalination.Inflow" [date] := "VolumeToFlow"( ( $ "Nevada ICS.NonSystemExchangesActualMonthlyPut" [date] / "SystemTaxAdjustment"(  ) ) COMMENTED_BY "Need to add system tax back in for real water", date );

      ENDFOREACH;

    END;

    RULE                 "Adjust CAP for Arizona ICS Take";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January 31, Current Year" AND NOT IsNaN $ "Mead Bank.Normal Year" [@"24:00:00 December 31, Current Year"];
    BEGIN

      BREAKPOINT BEFORE_EXEC FALSE;
    BREAKPOINT AFTER_EXEC FALSE;
      FOREACH (DATETIME date IN @"t" TO @"t + 11") DO
            FOREACH (STRING user IN "ListLBNormalWaterUsersByProvider"( "CAP" )) DO
            "GetObject"( "CAPDiversion:" CONCAT user ) & "Depletion Requested" [date] := "GetObject"( "CAPDiversion:" CONCAT user ) & "Depletion Requested" [date] + ( "VolumeToFlow"( $ "Arizona ICS.ActualMonthlyTake" [date] + $ "Arizona ICS.Drop2ActualMonthlyTake" [date] + $ "Arizona ICS.YDPActualMonthlyTake" [date], date ) * "LBUserToAggRatio"( "CAP", user, "Depletion", date ) );

            "GetObject"( "CAPDiversion:" CONCAT user ) & "Diversion Requested" [date] := "GetObject"( "CAPDiversion:" CONCAT user ) & "Diversion Requested" [date] + ( "VolumeToFlow"( $ "Arizona ICS.ActualMonthlyTake" [date] + $ "Arizona ICS.Drop2ActualMonthlyTake" [date] + $ "Arizona ICS.YDPActualMonthlyTake" [date], date ) * "LBUserToAggRatio"( "CAP", user, "Diversion", date ) );

      ENDFOREACH;

      ENDFOREACH;

    END;

    RULE                 "Compute Arizona Available ICS Water ";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January 31, Current Year";
    BEGIN

      FOREACH (DATETIME date IN @"t" TO @"24:00:00 December 31, Current Year") DO
            $ "Arizona ICS.ActualMonthlyPut" [date] := ( "DetermineArizonaAnnualPut"(  ) / 12.00000000 ) COMMENTED_BY "Put is from GilaGravityMainCanalPriority1.YumaCountyWUA";

            $ "Arizona ICS.ActualMonthlyTake" [date] := ( "DetermineArizonaAnnualTake"(  ) / 12.00000000 ) COMMENTED_BY "Take is by CAP";

            $ "Arizona ICS.Drop2ActualMonthlyTake" [date] := ( "DetermineAZDrop2Take"(  ) / 12.00000000 ) COMMENTED_BY "System Efficiency ICS - No Drop 2 put. Put always occurs through capturing of over-deliveries to Mexico. Take is by MWD";

            $ "Arizona ICS.YDPActualMonthlyTake" [date] := ( "DetermineAZYDPTake"(  ) / 12.00000000 );

      ENDFOREACH;

    END;

    RULE                 "Adjust MWD for California ICS Put/Take";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January 31, Current Year" AND NOT "HasRuleFiredSuccessfully"( "Adjust MWD for California ICS Put/Take" );
    BEGIN

      IF_STATEMENT ("NotSurplusYear"(  )) THEN
            FOREACH (DATETIME date IN @"t" TO @"t + 11") DO
            $ "MWDDiversion:MWDDiversion.Diversion Requested" [date] := $ "MWDSchedule.Diversion Schedule" [date] + "VolumeToFlow"( $ "California ICS.ActualMonthlyTake" [date] + $ "California ICS.BrockActualMonthlyTake" [date] + $ "California ICS.YDPActualMonthlyTake" [date], date ) - "VolumeToFlow"( ( $ "California ICS.ActualMonthlyPut" [date] / "SystemTaxAdjustment"(  ) ) COMMENTED_BY "Reduce diversion by 'real' water amount, so add system tax back in", date );

            $ "MWDDiversion:MWDDiversion.Depletion Requested" [date] := $ "MWDSchedule.Depletion Schedule" [date] + "VolumeToFlow"( $ "California ICS.ActualMonthlyTake" [date] + $ "California ICS.BrockActualMonthlyTake" [date] + $ "California ICS.YDPActualMonthlyTake" [date], date ) - "VolumeToFlow"( ( $ "California ICS.ActualMonthlyPut" [date] / "SystemTaxAdjustment"(  ) ) COMMENTED_BY "Reduce diversion by 'real' water amount, so add system tax back in", date );

      ENDFOREACH;

      END_IF_STATEMENT;

    END;

    RULE                 "Adjust MWD for California Brock Repay in Shortage";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January 31, Current Year" AND $ "California ICS.Drop2ActualMonthlyRepayInShortage" [] > 0.00000000 "acre-ft";
    BEGIN

      FOREACH (DATETIME date IN @"t" TO @"t + 11") DO
            $ "MWDDiversion.Total Diversion Requested" [date] := IF ( NOT IsNaN $ "Mead Bank.Normal Year" [@"24:00:00 December 31, Current Year"] )
   THEN
      $ "MWDSchedule.Diversion Schedule" [date]
   ELSE
      $ "MWDDiversion.Total Diversion Requested" [date]
   ENDIF - "VolumeToFlow"( $ "California ICS.Drop2ActualMonthlyRepayInShortage" [date], date );

            $ "MWDDiversion.Total Depletion Requested" [date] := IF ( NOT IsNaN $ "Mead Bank.Normal Year" [@"24:00:00 December 31, Current Year"] )
   THEN
      $ "MWDSchedule.Depletion Schedule" [date]
   ELSE
      $ "MWDDiversion.Total Depletion Requested" [date]
   ENDIF - "VolumeToFlow"( $ "California ICS.Drop2ActualMonthlyRepayInShortage" [date], date );

            $ "MWDSchedule.Drop2RepayInShortageFlag" [date] := 1.00000000;

      ENDFOREACH;

    END;

    RULE                 "Compute California Available ICS Water";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January 31, Current Year" AND NOT "HasRuleFiredSuccessfully"( "Adjust MWD for California ICS Put/Take" );
    BEGIN

      FOREACH (DATETIME date IN @"t" TO @"24:00:00 December Max DayOfMonth, Current Year") DO
            $ "California ICS.ActualMonthlyPut" [date] := ( "DetermineCaliforniaAnnualPut"(  ) / 12.00000000 ) COMMENTED_BY "Put is from MWD";

            $ "California ICS.ActualMonthlyTake" [date] := ( "DetermineCaliforniaAnnualTake"(  ) / 12.00000000 ) COMMENTED_BY "Take is by MWD";

            $ "California ICS.BrockActualMonthlyTake" [date] := ( "DetermineCABrockTake"(  ) / 12.00000000 ) COMMENTED_BY "System Efficiency ICS - No Drop 2 put. Put always occurs through capturing of over-deliveries to Mexico. Take is by MWD";

            $ "California ICS.YDPActualMonthlyTake" [date] := ( "DetermineCAYDPTake"(  ) / 12.00000000 ) COMMENTED_BY "System Efficiency ICS - No YDP put. Put occured through initial run of YDP. Take is by MWD";

      ENDFOREACH;

    END;

    RULE                 "Adjust SNWP for Nevada ICS Take and Other";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January 31, Current Year" AND ( "NotShortageYear"(  ) OR NOT IsNaN $ "Mead Bank.Normal Year" [@"24:00:00 December 31, Current Year"] );
    BEGIN

      FOREACH (DATETIME date IN @"t" TO @"t + 11") DO
            $ "SNWPDiversion:SNWPDiversion.Diversion Requested" [date] := IF ( NOT IsNaN $ "Mead Bank.Normal Year" [@"24:00:00 December 31, Current Year"] )
   THEN
      $ "SNWPSchedule.Diversion Schedule" [date]
   ELSE
      $ "SNWPDiversion:SNWPDiversion.Diversion Requested" [date]
   ENDIF + "VolumeToFlow"( "DetermineSNWPAdditionalProjectWater"( date ), date ) * ( $ "SNWPSchedule.Diversion Schedule" [date] / $ "SNWPSchedule.Depletion Schedule" [date] );

            $ "SNWPDiversion:SNWPDiversion.Depletion Requested" [date] := IF ( NOT IsNaN $ "Mead Bank.Normal Year" [@"24:00:00 December 31, Current Year"] )
   THEN
      $ "SNWPSchedule.Depletion Schedule" [date]
   ELSE
      $ "SNWPDiversion:SNWPDiversion.Depletion Requested" [date]
   ENDIF + "VolumeToFlow"( "DetermineSNWPAdditionalProjectWater"( date ), date );

      ENDFOREACH;

    END;

    RULE                 "Compute NV AZ Bank Take";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January 31, Current Year" AND NOT "HasRuleFiredSuccessfully"( "Compute NV AZ Bank Take" );
    BEGIN

      BREAKPOINT BEFORE_EXEC FALSE;
      FOREACH (DATETIME month IN @"t" TO @"24:00:00 December 31, Current Year") DO
            $ "Nevada ICS.AZBankActualMonthlyTake" [month] := "DetermineNVAZBankTake"(  ) / 12.00000000;

      ENDFOREACH;

    END;

    RULE                 "Compute NV Drop 2 Take";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January 31, Current Year" AND NOT "HasRuleFiredSuccessfully"( "Compute NV Drop 2 Take" );
    BEGIN

      FOREACH (DATETIME month IN @"t" TO @"24:00:00 December 31, Current Year") DO
            $ "Nevada ICS.Drop2ActualMonthlyTake" [month] := "DetermineNVDrop2Take"(  ) / 12.00000000;

      ENDFOREACH;

    END;

    RULE                 "Compute Nevada Mead Bank Put and Take";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January 31, Current Year" AND NOT "HasRuleFiredSuccessfully"( "Compute Nevada Mead Bank Put and Take" );
    BEGIN

      FOREACH (DATETIME month IN @"t" TO @"24:00:00 December 31, Current Year") DO
            $ "Nevada ICS.NVMeadBankActualMonthlyPut" [month] := "DetermineNVMeadBankPut"(  ) / 12.00000000;

            $ "Nevada ICS.NVMeadBankActualMonthlyTake" [month] := "DetermineNVMeadBankTake"(  ) / 12.00000000;

      ENDFOREACH;

    END;

    RULE                 "Compute Nevada Tributary and Imported ICS Puts/Takes";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January 31, Current Year" AND NOT "HasRuleFiredSuccessfully"( "Compute Nevada Tributary and Imported ICS Puts/Takes" );
    BEGIN

      FOREACH (DATETIME month IN @"t" TO @"24:00:00 December 31, Current Year") DO
            $ "Nevada ICS.TributaryConsActualMonthlyPut" [month] := "DetermineNevadaAnnualPut"(  ) / 12.00000000;

            $ "Nevada ICS.TributaryConsActualMonthlyTake" [month] := "DetermineNevadaAnnualTake"(  ) / 12.00000000;

            $ "Nevada ICS.GroundwaterActualMonthlyPut" [month] := "DetermineNVGroundwaterPut"(  ) / 12.00000000;

            $ "Nevada ICS.GroundwaterActualMonthlyTake" [month] := "DetermineNVGroundwaterTake"(  ) / 12.00000000;

      ENDFOREACH;

    END;

    RULE                 "Set ICMA slots for No ICMA";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January 31, Current Year" AND IsNaN $ "ICMA.ActualMonthlyPut" [];
    BEGIN

      FOREACH (DATETIME date IN @"t" TO @"24:00:00 December 31, Current Year") DO
            $ "ICMA.ActualMonthlyPut" [date] := 0.00000000 "acre-ft";

            $ "ICMA.ActualMonthlyTake" [date] := 0.00000000 "acre-ft";

            $ "ICMA.ActualMonthlyPulseFlow" [date] := 0.00000000 "acre-ft";

      ENDFOREACH;

    END;

  END;

  POLICY_GROUP   "Shortage Rules";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  BEGIN

    RULE                 "Monthly Absolute Protection (Level 2) Shortage for ICS";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT "ComputeWaterAvailableFromMeadAboveAnElevation"(  ) < "CurrentDemandBelowMead"(  ) AND ( @"t" >= @"October" OR NOT IsNaN $ "Shortage.CritPeriodLevel 2 Shortage Flag" [] ) COMMENTED_BY "We should be able to ignore affects of level 2 critical period short, since we require it to have already fired." AND @"t" > @"24:00:00 December 31, 2026" AND IF ( $ "Shortage.MWDShortageCounter" [@"t"] == 1.00000000 )
   THEN
      NOT IsNaN $ "Shortage.CritPeriodLevel 2 Shortage Flag" []
   ELSE
      TRUE
   ENDIF;
    BEGIN

      FOREACH (STRING diversion IN IF ( $ "Mead.Pool Elevation" [@"t - 1"] < $ "MeadProrationScheme.SNWPMinPumpingElevation" [0.00000000, 0.00000000] )
   THEN
      { "CAP" , "Mexico" , "MWD" }
   ELSE
      { "CAP" , "SNWP" , "Mexico" , "MWD" }
   ENDIF) DO
            diversion CONCAT "Diversion.Total Diversion Requested" [] := IF ( diversion CONCAT "Diversion.Total Diversion Requested" [] > 0.00000000 "acre-ft/month" )
   THEN
      "ComputeAbsoluteProtectionShortageDiversion"( diversion, % "Mead" COMMENTED_BY "Has no significance, just needed an existing object to pass" ) + IF ( diversion == "SNWP" AND $ "Shortage.MWDShortageCounter" [@"t"] == 1.00000000 AND IsNaN $ "Shortage.CritPeriodLevel 2 Shortage Flag" [] )
      THEN
         "VolumeToFlow"( "DetermineSNWPAdditionalProjectWater"( @"t" ), @"t" ) * ( $ "SNWPSchedule.Diversion Schedule" [] / $ "SNWPSchedule.Depletion Schedule" [] )
      ELSE
         0.00000000 "acre-ft/month"
      ENDIF
   ENDIF;

            diversion CONCAT "Diversion.Total Depletion Requested" [] := "ComputeAbsoluteProtectionShortageDepletion"( diversion, % "Mead" COMMENTED_BY "Has no significance, just needed an existing object to pass" ) + IF ( diversion == "SNWP" AND $ "Shortage.MWDShortageCounter" [@"t"] == 1.00000000 AND IsNaN $ "Shortage.CritPeriodLevel 2 Shortage Flag" [] )
   THEN
      "VolumeToFlow"( "DetermineSNWPAdditionalProjectWater"( @"t" ), @"t" )
   ELSE
      0.00000000 "acre-ft/month"
   ENDIF;

            FOREACH (OBJECT diversion IN "OtherArizonaPriority4UsersWaterUser"(  )) DO
            diversion CONCAT ".Diversion Requested" [] := IF ( diversion CONCAT ".Diversion Requested" [] > 0.00000000 "acre-ft/month" )
   THEN
      "ComputeAbsoluteProtectionShortageDiversion"( "GetSlotNameForScheduleWaterUser"( STRINGIFY diversion ), diversion )
   ENDIF;

            diversion CONCAT ".Depletion Requested" [] := IF ( diversion CONCAT ".Depletion Requested" [] > 0.00000000 "acre-ft/month" )
   THEN
      "ComputeAbsoluteProtectionShortageDepletion"( "GetSlotNameForScheduleWaterUser"( STRINGIFY diversion ), diversion )
   ENDIF;

      ENDFOREACH;

            FOREACH (OBJECT diversion IN "ArizonaPriority2and3UsersWaterUser"(  )) DO
            diversion CONCAT ".Diversion Requested" [] := IF ( diversion CONCAT ".Diversion Requested" [] > 0.00000000 "acre-ft/month" )
   THEN
      "ComputeAbsoluteProtectionShortageDiversion"( "GetSlotNameForScheduleWaterUser"( STRINGIFY diversion ), diversion )
   ENDIF;

            diversion CONCAT ".Depletion Requested" [] := IF ( diversion CONCAT ".Depletion Requested" [] > 0.00000000 "acre-ft/month" )
   THEN
      "ComputeAbsoluteProtectionShortageDepletion"( "GetSlotNameForScheduleWaterUser"( STRINGIFY diversion ), diversion )
   ENDIF;

      ENDFOREACH;

            diversion CONCAT "Schedule.ShortageScheduleFlag" [] := 1.00000000;

            diversion CONCAT "Schedule.SurplusScheduleFlag" [@"t"] := 0.00000000;

      ENDFOREACH;

      $ "Surplus.SurplusFlag" [] := 0.00000000;

      $ "Shortage.ShortageFlag" [] := 1.00000000;

      $ "Shortage.Monthly Level 2 Shortage Flag" [] := 1.00000000;

      $ "Shortage.Stage2Shortage" [] := "AbsoluteProtectionLevelShortageToAllocateMONTH"(  );

      $ "Shortage.Stage2ShortageCHECK" [] := "AbsoluteProtectionLevelShortageToAllocateMONTH"(  ) + ( FOR ( STRING diversion IN { "CAP" , "SNWP" , "Mexico" , "MWD" } ) WITH NUMERIC result = 0.00000000 "acre-ft/month" DO
      result + diversion CONCAT "Diversion.Total Depletion Requested" [] - "ComputeAbsoluteProtectionShortageDepletion"( diversion, % "Mead" )
   ENDFOR + ( FOR ( OBJECT diversion IN "OtherArizonaPriority4UsersWaterUser"(  ) ) WITH NUMERIC result = 0.00000000 "acre-ft/month" DO
      result + diversion CONCAT ".Depletion Requested" [] - "ComputeAbsoluteProtectionShortageDepletion"( "GetSlotNameForScheduleWaterUser"( STRINGIFY diversion ), diversion )
   ENDFOR + FOR ( OBJECT diversion IN "ArizonaPriority2and3UsersWaterUser"(  ) ) WITH NUMERIC result = 0.00000000 "acre-ft/month" DO
      result + diversion CONCAT ".Depletion Requested" [] - "ComputeAbsoluteProtectionShortageDepletion"( "GetSlotNameForScheduleWaterUser"( STRINGIFY diversion ), diversion )
   ENDFOR ) );

    END;

    RULE                 "Jan-Sept Absolute Protection (Level 2) Shortage for ICS";
    DESCRIPTION          "This rule sets CAP and the other Priority 4 Arizona Users to zero for the current month if Mead is forecasted to go below 1000 ft in July.";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT ( @"t" < @"October" AND @"t" > @"24:00:00 December 31, 2026" AND ( $ "Shortage.ShortageFlag" [] == 1.00000000 ) COMMENTED_BY "We should be able to ignore effects of level 1 short, since we require it to have already fired." AND "CriticalPeriodVolumeCheck"(  ) COMMENTED_BY "Checks now or May through (and including) September, water availability" AND IsNaN $ "Shortage.CritPeriodLevel 2 Shortage Flag" [] ) OR ( ( $ "Shortage.MWDShortageCounter" [@"t"] == 1.00000000 AND @"t" > @"24:00:00 December 31, 2026" ) AND ( $ "Shortage.ShortageFlag" [] == 1.00000000 ) ) OR ( ( $ "EqualizationData.BypassCapFlag" [@"t"] == 1.00000000 AND @"t" > @"24:00:00 December 31, 2026" ) AND ( $ "Shortage.ShortageFlag" [] == 1.00000000 ) );
    BEGIN

      FOREACH (STRING diversion IN IF ( $ "Mead.Pool Elevation" [@"t - 1"] < $ "MeadProrationScheme.SNWPMinPumpingElevation" [0.00000000, 0.00000000] )
   THEN
      { "CAP" , "Mexico" }
   ELSE
      { "SNWP" , "CAP" , "Mexico" }
   ENDIF) DO
            diversion CONCAT "Diversion.Total Diversion Requested" [] := IF ( diversion CONCAT "Diversion.Total Diversion Requested" [] > 0.00000000 "acre-ft/month" )
   THEN
      "ComputeAPCritPeriodShortageDiversion"( diversion ) + IF ( diversion == "SNWP" )
      THEN
         "VolumeToFlow"( "DetermineSNWPAdditionalProjectWater"( @"t" ), @"t" ) * ( $ "SNWPSchedule.Diversion Schedule" [] / $ "SNWPSchedule.Depletion Schedule" [] )
      ELSE
         0.00000000 "acre-ft/month"
      ENDIF
   ENDIF;

            diversion CONCAT "Diversion.Total Depletion Requested" [] := IF ( diversion CONCAT "Diversion.Total Depletion Requested" [] > 0.00000000 "acre-ft/month" )
   THEN
      "ComputeAPCritPeriodShortageDepletion"( diversion ) + IF ( diversion == "SNWP" )
      THEN
         "VolumeToFlow"( "DetermineSNWPAdditionalProjectWater"( @"t" ), @"t" )
      ELSE
         0.00000000 "acre-ft/month"
      ENDIF
   ENDIF;

            FOREACH (OBJECT diversion IN "OtherArizonaPriority4UsersWaterUser"(  )) DO
            diversion CONCAT ".Diversion Requested" [] := "ComputeAPCritPeriodShortageDiversion"( "GetSlotNameForScheduleWaterUser"( STRINGIFY diversion ) );

            diversion CONCAT ".Depletion Requested" [] := "ComputeAPCritPeriodShortageDepletion"( "GetSlotNameForScheduleWaterUser"( STRINGIFY diversion ) );

      ENDFOREACH;

            FOREACH (OBJECT diversion IN "ArizonaPriority2and3UsersWaterUser"(  )) DO
            diversion CONCAT ".Diversion Requested" [] := "ArizonaPriority2and3Schedules.Diversion_" CONCAT "GetSlotNameForScheduleWaterUser"( STRINGIFY diversion ) [];

            diversion CONCAT ".Depletion Requested" [] := "ArizonaPriority2and3Schedules.Depletion_" CONCAT "GetSlotNameForScheduleWaterUser"( STRINGIFY diversion ) [];

      ENDFOREACH;

            diversion CONCAT "Schedule.ShortageScheduleFlag" [] := 1.00000000;

            diversion CONCAT "Schedule.SurplusScheduleFlag" [@"t"] := 0.00000000;

      ENDFOREACH;

      $ "Surplus.SurplusFlag" [] := 0.00000000;

      $ "Shortage.ShortageFlag" [] := 1.00000000;

      $ "Shortage.Stage1Shortage" [] := "TotalLBShortageArizonaPriority4Zero"(  );

      $ "Shortage.CritPeriodLevel 2 Shortage Flag" [] := 1.00000000;

    END;

    RULE                 "Shortage (80P1050) for ICS";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January 31, Current Year" AND $ "Mead.Pool Elevation" [@"t - 1"] < $ "Shortage.Mead Trigger 80P1050" [@"t - 1"] AND @"t" > @"24:00:00 December 31, 2026" AND IsNaN $ "SNWPDiversion.Total Depletion Requested" [];
    BEGIN

      FOREACH (DATETIME date IN @"t" TO @"24:00:00 December 31, Current Year") DO
            FOREACH (STRING diversion IN { "CAP" , "SNWP" , "Mexico" }) DO
            diversion CONCAT "Diversion.Total Diversion Requested" [date] := "ComputeShortageDiversion"( diversion, date ) + IF ( diversion == "SNWP" )
   THEN
      "VolumeToFlow"( "DetermineSNWPAdditionalProjectWater"( date ), date ) * ( $ "SNWPSchedule.Diversion Schedule" [date] / $ "SNWPSchedule.Depletion Schedule" [date] )
   ELSE
      0.00000000 "acre-ft/month"
   ENDIF;

            diversion CONCAT "Diversion.Total Depletion Requested" [date] := "ComputeShortageDepletion"( diversion, date ) + IF ( diversion == "SNWP" )
   THEN
      "VolumeToFlow"( "DetermineSNWPAdditionalProjectWater"( date ), date )
   ELSE
      0.00000000 "acre-ft/month"
   ENDIF;

            diversion CONCAT "Schedule.ShortageScheduleFlag" [date] := 1.00000000;

            diversion CONCAT "Schedule.SurplusScheduleFlag" [date] := 0.00000000;

      ENDFOREACH;

            FOREACH (OBJECT diversion IN "OtherArizonaPriority4UsersWaterUser"(  )) DO
            diversion CONCAT ".Diversion Requested" [date] := "ComputeShortageDiversion"( "GetSlotNameForScheduleWaterUser"( STRINGIFY diversion ), date );

            diversion CONCAT ".Depletion Requested" [date] := "ComputeShortageDepletion"( "GetSlotNameForScheduleWaterUser"( STRINGIFY diversion ), date );

      ENDFOREACH;

            FOREACH (OBJECT diversion IN "ArizonaPriority2and3UsersWaterUser"(  )) DO
            diversion CONCAT ".Diversion Requested" [date] := "ArizonaPriority2and3Schedules.Diversion_" CONCAT "GetSlotNameForScheduleWaterUser"( STRINGIFY diversion ) [date];

            diversion CONCAT ".Depletion Requested" [date] := "ArizonaPriority2and3Schedules.Depletion_" CONCAT "GetSlotNameForScheduleWaterUser"( STRINGIFY diversion ) [date];

      ENDFOREACH;

            $ "Surplus.SurplusFlag" [date] := 0.00000000;

            $ "Shortage.ShortageFlag" [date] := 1.00000000;

            $ "Shortage.80P1050 Shortage Flag" [date] := 1.00000000;

      ENDFOREACH;

      $ "Shortage.Annual Level 1 Shortage" [] := "TotalLevel1LBShortage"(  );

    END;

    RULE                 "Step 3 Shortage for ICS";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January 31, Current Year" AND $ "SystemConditions.LBShortageTier" [@"24:00:00 December Max DayOfMonth, Current Year"] == 3.00000000 AND IsNaN $ "SNWPDiversion.Total Depletion Requested" [];
    BEGIN

      FOREACH (DATETIME date IN @"t" TO @"24:00:00 December Max DayOfMonth, Current Year") DO
            FOREACH (STRING diversion IN { "CAP" , "SNWP" , "Mexico" }) DO
            FOREACH (STRING user IN "ListLBNormalWaterUsersByProvider"( diversion )) DO
            "GetObject"( diversion CONCAT "Diversion:" CONCAT user ) & "Depletion Requested" [date] := "ComputeStepShortageDepletion"( diversion, 3.00000000, date, user ) * "LBUserToAggRatio"( diversion, user, "Depletion", date ) + IF ( diversion == "SNWP" )
   THEN
      "VolumeToFlow"( "DetermineSNWPAdditionalProjectWater"( date ), date )
   ELSE
      0.00000000 "acre-ft/month"
   ENDIF;

            "GetObject"( diversion CONCAT "Diversion:" CONCAT user ) & "Diversion Requested" [date] := "ComputeStepShortageDiversion"( diversion, 3.00000000, date, user ) * "LBUserToAggRatio"( diversion, user, "Diversion", date ) + IF ( diversion == "SNWP" )
   THEN
      ( "VolumeToFlow"( "DetermineSNWPAdditionalProjectWater"( date ), date ) * ( $ "SNWPSchedule.Diversion Schedule" [date] / $ "SNWPSchedule.Depletion Schedule" [date] ) )
   ELSE
      0.00000000 "acre-ft/month"
   ENDIF;

      ENDFOREACH;

            diversion CONCAT "Schedule.ShortageScheduleFlag" [date] := 1.00000000;

            diversion CONCAT "Schedule.SurplusScheduleFlag" [date] := 0.00000000;

      ENDFOREACH;

            FOREACH (OBJECT diversion IN "OtherArizonaPriority4UsersWaterUser"(  )) DO
            diversion CONCAT ".Diversion Requested" [date] := "ComputeStepShortageDiversion"( "GetSlotNameForScheduleWaterUser"( STRINGIFY diversion ), 3.00000000, date, STRINGIFY diversion );

            diversion CONCAT ".Depletion Requested" [date] := "ComputeStepShortageDepletion"( "GetSlotNameForScheduleWaterUser"( STRINGIFY diversion ), 3.00000000, date, STRINGIFY diversion );

      ENDFOREACH;

            $ "Surplus.SurplusFlag" [date] := 0.00000000;

            $ "Shortage.ShortageFlag" [date] := 1.00000000;

            $ "Shortage.Step 3 Shortage Flag" [date] := 1.00000000;

      ENDFOREACH;

    END;

    RULE                 "Step 2 Shortage for ICS";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January 31, Current Year" AND $ "SystemConditions.LBShortageTier" [@"24:00:00 December Max DayOfMonth, Current Year"] == 2.00000000 AND IsNaN $ "SNWPDiversion.Total Depletion Requested" [];
    BEGIN

      FOREACH (DATETIME date IN @"t" TO @"24:00:00 December 31, Current Year") DO
            FOREACH (STRING diversion IN { "CAP" , "SNWP" , "Mexico" }) DO
            FOREACH (STRING user IN "ListLBNormalWaterUsersByProvider"( diversion )) DO
            "GetObject"( diversion CONCAT "Diversion:" CONCAT user ) & "Depletion Requested" [date] := "ComputeStepShortageDepletion"( diversion, 2.00000000, date, user ) * "LBUserToAggRatio"( diversion, user, "Depletion", date ) + IF ( diversion == "SNWP" )
   THEN
      "VolumeToFlow"( "DetermineSNWPAdditionalProjectWater"( date ), date )
   ELSE
      0.00000000 "acre-ft/month"
   ENDIF;

            "GetObject"( diversion CONCAT "Diversion:" CONCAT user ) & "Diversion Requested" [date] := "ComputeStepShortageDiversion"( diversion, 2.00000000, date, user ) * "LBUserToAggRatio"( diversion, user, "Diversion", date ) + IF ( diversion == "SNWP" )
   THEN
      ( "VolumeToFlow"( "DetermineSNWPAdditionalProjectWater"( date ), date ) * ( $ "SNWPSchedule.Diversion Schedule" [date] / $ "SNWPSchedule.Depletion Schedule" [date] ) )
   ELSE
      0.00000000 "acre-ft/month"
   ENDIF;

      ENDFOREACH;

            diversion CONCAT "Schedule.ShortageScheduleFlag" [date] := 1.00000000;

            diversion CONCAT "Schedule.SurplusScheduleFlag" [date] := 0.00000000;

      ENDFOREACH;

            FOREACH (OBJECT diversion IN "OtherArizonaPriority4UsersWaterUser"(  )) DO
            diversion CONCAT ".Diversion Requested" [date] := "ComputeStepShortageDiversion"( "GetSlotNameForScheduleWaterUser"( STRINGIFY diversion ), 2.00000000, date, STRINGIFY diversion );

            diversion CONCAT ".Depletion Requested" [date] := "ComputeStepShortageDepletion"( "GetSlotNameForScheduleWaterUser"( STRINGIFY diversion ), 2.00000000, date, STRINGIFY diversion );

      ENDFOREACH;

            $ "Surplus.SurplusFlag" [date] := 0.00000000;

            $ "Shortage.ShortageFlag" [date] := 1.00000000;

            $ "Shortage.Step 2 Shortage Flag" [date] := 1.00000000;

      ENDFOREACH;

    END;

    RULE                 "Step 1 Shortage for ICS";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January 31, Current Year" AND $ "SystemConditions.LBShortageTier" [@"24:00:00 December Max DayOfMonth, Current Year"] == 1.00000000 AND IsNaN $ "SNWPDiversion.Total Depletion Requested" [];
    BEGIN

      BREAKPOINT BEFORE_EXEC TRUE;
      FOREACH (DATETIME date IN @"t" TO @"24:00:00 December 31, Current Year") DO
            FOREACH (STRING diversion IN { "CAP" , "SNWP" , "Mexico" }) DO
            FOREACH (STRING user IN "ListLBNormalWaterUsersByProvider"( diversion )) DO
            "GetObject"( diversion CONCAT "Diversion:" CONCAT user ) & "Depletion Requested" [date] := "ComputeStepShortageDepletion"( diversion, 1.00000000, date, user ) * "LBUserToAggRatio"( diversion, user, "Depletion", date ) + IF ( diversion == "SNWP" )
   THEN
      "VolumeToFlow"( "DetermineSNWPAdditionalProjectWater"( date ), date )
   ELSE
      0.00000000 "acre-ft/month"
   ENDIF;

            "GetObject"( diversion CONCAT "Diversion:" CONCAT user ) & "Diversion Requested" [date] := "ComputeStepShortageDiversion"( diversion, 1.00000000, date, user ) * "LBUserToAggRatio"( diversion, user, "Diversion", date ) + IF ( diversion == "SNWP" )
   THEN
      ( "VolumeToFlow"( "DetermineSNWPAdditionalProjectWater"( date ), date ) * ( $ "SNWPSchedule.Diversion Schedule" [date] / $ "SNWPSchedule.Depletion Schedule" [date] ) )
   ELSE
      0.00000000 "acre-ft/month"
   ENDIF;

      ENDFOREACH;

            diversion CONCAT "Schedule.ShortageScheduleFlag" [date] := 1.00000000;

            diversion CONCAT "Schedule.SurplusScheduleFlag" [date] := 0.00000000;

      ENDFOREACH;

            FOREACH (OBJECT diversion IN "OtherArizonaPriority4UsersWaterUser"(  )) DO
            diversion CONCAT ".Diversion Requested" [date] := "ComputeStepShortageDiversion"( "GetSlotNameForScheduleWaterUser"( STRINGIFY diversion ), 1.00000000, date, STRINGIFY diversion );

            diversion CONCAT ".Depletion Requested" [date] := "ComputeStepShortageDepletion"( "GetSlotNameForScheduleWaterUser"( STRINGIFY diversion ), 1.00000000, date, STRINGIFY diversion );

      ENDFOREACH;

            $ "Surplus.SurplusFlag" [date] := 0.00000000;

            $ "Shortage.ShortageFlag" [date] := 1.00000000;

            $ "Shortage.Step 1 Shortage Flag" [date] := 1.00000000;

      ENDFOREACH;

    END;

    RULE                 "Set Shortage Tier";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January 31, Current Year" AND NOT "HasRuleFiredSuccessfully"( "ThisRule" ) AND NOT "IsInput"( $ "SystemConditions.LBShortageTier", @"24:00:00 December Max DayOfMonth, Current Year" );
    BEGIN

      $ "SystemConditions.LBShortageTier" [@"24:00:00 December Max DayOfMonth, Current Year"] := "DetermineShortageTier"(  );

    END;

  END;

  POLICY_GROUP   "Surplus Rules";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  BEGIN

    RULE                 "MWD and PVID Surplus Fallowing";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT ( NOT IsNaN $ "Surplus.SurplusRelease" [] AND ( ( ( NOT "NotSurplusYear"(  ) ) AND @"t" == @"January" ) AND $ "California ICS.PVID Fallow Amount" [@"24:00:00 December 31, Current Year"] > 0.00000000 "acre-ft" ) ) COMMENTED_BY ">:-)";
    BEGIN

      FOREACH (DATETIME date IN @"t" TO @"24:00:00 December 31, Current Year") DO
            $ "MWDSchedule.Diversion Schedule" [date] := $ "MWDSchedule.Input Diversion Normal Schedule" [date] + "VolumeToFlow"( $ "California ICS.Minimum PVID Fallow Amount" [] * "SurplusMonthlyPercent"( "MWD", date ), date );

            $ "MWDSchedule.Depletion Schedule" [date] := $ "MWDSchedule.Input Depletion Normal Schedule" [date] + "VolumeToFlow"( $ "California ICS.Minimum PVID Fallow Amount" [] * "SurplusMonthlyPercent"( "MWD", date ), date );

            $ "MWDSchedule.Input Diversion Schedule" [date] := $ "MWDSchedule.Input Diversion Normal Schedule" [date];

            $ "MWDSchedule.Input Depletion Schedule" [date] := $ "MWDSchedule.Input Depletion Normal Schedule" [date];

            $ "PVIDDiversion.Total Diversion Requested" [date] := $ "PVIDSchedule.Input Diversion Schedule" [date] - "VolumeToFlow"( $ "California ICS.Minimum PVID Fallow Amount" [] * "SurplusMonthlyPercent"( "PVID", date ), date ) * ( $ "PVIDSchedule.Input Diversion Schedule" [date] / $ "PVIDSchedule.Input Depletion Schedule" [date] );

            $ "PVIDSchedule.Diversion Schedule" [date] := $ "PVIDSchedule.Input Diversion Schedule" [date] - "VolumeToFlow"( $ "California ICS.Minimum PVID Fallow Amount" [] * "SurplusMonthlyPercent"( "PVID", date ), date ) * ( $ "PVIDSchedule.Input Diversion Schedule" [date] / $ "PVIDSchedule.Input Depletion Schedule" [date] );

            $ "PVIDDiversion.Total Depletion Requested" [date] := $ "PVIDSchedule.Input Depletion Schedule" [date] - "VolumeToFlow"( $ "California ICS.Minimum PVID Fallow Amount" [] * "SurplusMonthlyPercent"( "PVID", date ), date );

            $ "PVIDSchedule.Depletion Schedule" [date] := $ "PVIDSchedule.Input Depletion Schedule" [date] - "VolumeToFlow"( $ "California ICS.Minimum PVID Fallow Amount" [] * "SurplusMonthlyPercent"( "PVID", date ), date );

      ENDFOREACH;

    END;

    RULE                 "Quantified 7 State Plan Level 1 Surplus";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January 31, Current Year" AND $ "Surplus.SurplusRelease" [] > 0.00000000 "acre-feet" AND IsNaN $ "SNWPDiversion.Total Depletion Requested" [];
    BEGIN

      FOREACH (DATETIME date IN @"t" TO @"24:00:00 December 31, Current Year") DO
            $ "Surplus.SurplusFlag" [date] := 1.00000000;

            $ "Shortage.ShortageFlag" [date] := 0.00000000;

            $ "Surplus.Quantified Surplus Flag" [date] := 1.00000000;

            FOREACH (STRING diversion IN { "MWD" , "CAP" , "SNWP" , "Coachella" , "IID" }) DO
            FOREACH (STRING user IN "ListLBNormalWaterUsersByProvider"( diversion )) DO
            "GetObject"( diversion CONCAT "Diversion:" CONCAT user ) & "Depletion Requested" [date] := ( "ComputeSurplusDepl7StatePlanLevel1"( diversion, date ) + IF ( diversion == "MWD" )
   THEN
      "GetMWDDeliveryAdjustment"( date, "Depletion" )
   ELSE
      IF ( diversion == "CAP" )
      THEN
         "GetCAPDeliveryAdjustment"( date )
      ELSE
         0.00000000 "acre-ft/month"
      ENDIF
   ENDIF ) * "LBUserToAggRatio"( diversion, user, "Depletion", date );

            "GetObject"( diversion CONCAT "Diversion:" CONCAT user ) & "Diversion Requested" [date] := ( "ComputeSurplusDiv7StatePlanLevel1"( diversion, date ) + IF ( diversion == "MWD" )
   THEN
      "GetMWDDeliveryAdjustment"( date, "Diversion" )
   ELSE
      IF ( diversion == "CAP" )
      THEN
         "GetCAPDeliveryAdjustment"( date )
      ELSE
         0.00000000 "acre-ft/month"
      ENDIF
   ENDIF ) * "LBUserToAggRatio"( diversion, user, "Diversion", date );

      ENDFOREACH;

            diversion CONCAT "Schedule.ShortageScheduleFlag" [date] := 0.00000000;

            diversion CONCAT "Schedule.SurplusScheduleFlag" [date] := IF ( "ComputeSurplusDepl7StatePlanLevel1"( diversion, date ) > IF ( diversion == "IID" OR diversion == "Coachella" )
   THEN
      diversion CONCAT "Schedule.Total Depletion Schedule" []
   ELSE
      diversion CONCAT "Schedule.Depletion Schedule" []
   ENDIF )
   THEN
      1.00000000
   ELSE
      0.00000000
   ENDIF;

            diversion CONCAT "Schedule.SurplusLevel1Flag" [date] := IF ( "ComputeSurplusDepl7StatePlanLevel1"( diversion, date ) > IF ( diversion == "IID" OR diversion == "Coachella" )
   THEN
      diversion CONCAT "Schedule.Total Depletion Schedule" []
   ELSE
      diversion CONCAT "Schedule.Depletion Schedule" []
   ENDIF )
   THEN
      1.00000000
   ELSE
      0.00000000
   ENDIF;

            "LBSurplus." CONCAT diversion [date] := "ComputeSurplusDepl7StatePlanLevel1"( diversion, date ) - IF ( diversion == "MWD" )
   THEN
      diversion CONCAT "Schedule.Input Depletion Normal Schedule" [date]
   ELSE
      IF ( diversion == "IID" OR diversion == "Coachella" )
      THEN
         diversion CONCAT "Schedule.Total Depletion Schedule" []
      ELSE
         diversion CONCAT "Schedule.Depletion Schedule" []
      ENDIF
   ENDIF;

      ENDFOREACH;

            $ "Nevada ICS.SNGWBankPut" [date] := "Min"( "Max"( "Max"( "ComputeLevel2RequestedAboveNormal"( "SNWP" ), "ComputeQuantifiedLevel1Volume"( "SNWP" ) ) - $ "NevadaUnmetDemandSchedules.NVAnnualScheduledUnmetDemand" [@"24:00:00 December Max DayOfMonth, Current Year"], 0.00000000 "acre-ft" ), $ "Nevada ICS.SNGWBankDeposit" [] ) / 12.00000000;

      ENDFOREACH;

    END;

    RULE                 "Domestic 7 State Plan Level 2 Surplus";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January 31, Current Year" AND ( $ "Mead.Pool Elevation" [@"t - 1"] >= $ "Surplus Triggers.7 State Plan Level 2" [@"t - 1"] AND $ "Surplus.SurplusRelease" [] <= 0.00000000 "acre-feet" ) AND IsNaN $ "SNWPDiversion.Total Depletion Requested" [];
    BEGIN

    BREAKPOINT AFTER_EXEC FALSE;
      FOREACH (DATETIME date IN @"t" TO @"24:00:00 December 31, Current Year") DO
            $ "Surplus.SurplusFlag" [date] := 1.00000000;

            $ "Shortage.ShortageFlag" [date] := 0.00000000;

            $ "Surplus.Full Domestic Surplus Flag" [date] := 1.00000000;

            FOREACH (STRING diversion IN { "MWD" , "SNWP" , "CAP" }) DO
            BREAKPOINT BEFORE_EXEC FALSE;
      FOREACH (STRING user IN "ListLBNormalWaterUsersByProvider"( diversion )) DO
            BREAKPOINT BEFORE_EXEC FALSE;
      "GetObject"( diversion CONCAT "Diversion:" CONCAT user ) & "Depletion Requested" [date] := ( "ComputeSurplusDepl7StatePlanLevel2"( diversion, date ) + IF ( diversion == "MWD" )
   THEN
      "GetMWDDeliveryAdjustment"( date, "Depletion" )
   ELSE
      IF ( diversion == "CAP" )
      THEN
         "GetCAPDeliveryAdjustment"( date )
      ELSE
         0.00000000 "acre-ft/month"
      ENDIF
   ENDIF ) * "LBUserToAggRatio"( diversion, user, "Depletion", date );

            "GetObject"( diversion CONCAT "Diversion:" CONCAT user ) & "Diversion Requested" [date] := ( "ComputeSurplusDiv7StatePlanLevel2"( diversion, date ) + IF ( diversion == "MWD" )
   THEN
      "GetMWDDeliveryAdjustment"( date, "Diversion" )
   ELSE
      IF ( diversion == "CAP" )
      THEN
         "GetCAPDeliveryAdjustment"( date )
      ELSE
         0.00000000 "acre-ft/month"
      ENDIF
   ENDIF ) * "LBUserToAggRatio"( diversion, user, "Diversion", date );

      ENDFOREACH;

            diversion CONCAT "Schedule.ShortageScheduleFlag" [date] := 0.00000000;

            diversion CONCAT "Schedule.SurplusScheduleFlag" [date] := 1.00000000;

            diversion CONCAT "Schedule.SurplusLevel2Flag" [date] := 1.00000000;

            "LBSurplus." CONCAT diversion [date] := "ComputeSurplusDepl7StatePlanLevel2"( diversion, date ) - IF ( diversion == "MWD" )
   THEN
      diversion CONCAT "Schedule.Input Depletion Normal Schedule" [date]
   ELSE
      diversion CONCAT "Schedule.Depletion Schedule" [date]
   ENDIF;

      ENDFOREACH;

      ENDFOREACH;

    END;

    RULE                 "70R Assurance Level Surplus";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January 31, Current Year" AND $ "Surplus.SurplusRelease" [] > 0.00000000 "acre-feet" AND @"t" >= @"24:00:00 January 31, 2027" AND IsNaN $ "SNWPDiversion.Total Depletion Requested" [];
    BEGIN

      FOREACH (DATETIME date IN @"t" TO @"24:00:00 December 31, Current Year") DO
            $ "Surplus.SurplusFlag" [date] := 1.00000000;

            $ "Surplus.Normal 70R Surplus Flag" [date] := 1.00000000;

            $ "Shortage.ShortageFlag" [date] := 0.00000000;

            FOREACH (STRING diversion IN { "MWD" , "CAP" , "SNWP" }) DO
            diversion CONCAT "Diversion.Total Diversion Requested" [date] := "ComputeSurplusDiversion"( diversion, date ) + IF ( diversion == "MWD" )
   THEN
      $ "MWDSchedule.AnnualReturnFlow" [@"24:00:00 December Max DayOfMonth, Current Year"]
   ELSE
      0.00000000 "acre-ft/month"
   ENDIF;

            diversion CONCAT "Diversion.Total Depletion Requested" [date] := "ComputeSurplusDepletion"( diversion, date );

            diversion CONCAT "Schedule.ShortageScheduleFlag" [date] := 0.00000000;

            diversion CONCAT "Schedule.SurplusScheduleFlag" [date] := 1.00000000;

            "LBSurplus." CONCAT diversion [date] := "ComputeSurplusDepletion"( diversion, date ) - IF ( diversion == "MWD" )
   THEN
      diversion CONCAT "Schedule.Input Depletion Normal Schedule" [date]
   ELSE
      diversion CONCAT "Schedule.Depletion Schedule" [date]
   ENDIF;

      ENDFOREACH;

            $ "Nevada ICS.SNGWBankPut" [date] := "Min"( "Max"( $ "No Action Annual Surplus Schedules.SNWP Surplus Schedule" [@"24:00:00 December Max DayOfMonth, Current Year"] - "SumFlowsToVolume"( $ "SNWPSchedule.Depletion Schedule", @"24:00:00 January Max DayOfMonth, Current Year", @"24:00:00 December Max DayOfMonth, Current Year" ) - $ "NevadaUnmetDemandSchedules.NevadaAnnualScheduledAdditionalDemand" [@"24:00:00 December Max DayOfMonth, Current Year"], 0.00000000 "acre-ft" ), $ "Nevada ICS.SNGWBankDeposit" [] ) / 12.00000000;

          DESCRIPTION          "Coachella; Distribute Surplus proportionally amongst water users";
      FOREACH (STRING user IN { "CoachellaDiversionAG" , "CoachellaDiversionMandI" , "CoachellaDiversionFWR" }) DO
            "GetObject"( "CoachellaDiversion:" CONCAT user ) & "Depletion Requested" [date] := "ComputeSurplusDepletion"( "Coachella", date ) * "CAUserToAggRatio"( "Coachella", user, "Depletion", date );

            "GetObject"( "CoachellaDiversion:" CONCAT user ) & "Diversion Requested" [date] := "ComputeSurplusDiversion"( "Coachella", date ) * "CAUserToAggRatio"( "Coachella", user, "Diversion", date );

      ENDFOREACH;

            $ "CoachellaSchedule.ShortageScheduleFlag" [date] := 0.00000000;

            $ "CoachellaSchedule.SurplusScheduleFlag" [date] := 1.00000000;

            $ "LBSurplus.Coachella" [date] := "ComputeSurplusDepletion"( "Coachella", date ) - $ "CoachellaSchedule.Total Depletion Schedule" [date];

          DESCRIPTION          "IID; Distribute Surplus proportionally amongst water users";
      FOREACH (STRING user IN { "IIDDiversionAG" , "IIDDiversionMandI" , "IIDDiversionNRG" , "IIDDiversionFWR" }) DO
            "GetObject"( "IIDDiversion:" CONCAT user ) & "Depletion Requested" [date] := "ComputeSurplusDepletion"( "IID", date ) * "CAUserToAggRatio"( "IID", user, "Depletion", date );

            "GetObject"( "IIDDiversion:" CONCAT user ) & "Diversion Requested" [date] := "ComputeSurplusDiversion"( "IID", date ) * "CAUserToAggRatio"( "IID", user, "Diversion", date );

      ENDFOREACH;

            $ "IIDSchedule.ShortageScheduleFlag" [date] := 0.00000000;

            $ "IIDSchedule.SurplusScheduleFlag" [date] := 1.00000000;

            $ "LBSurplus.IID" [date] := "ComputeSurplusDepletion"( "IID", date ) - $ "IIDSchedule.Total Depletion Schedule" [date];

      ENDFOREACH;

    END;

  END;

  POLICY_GROUP   "Navajo Rules";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  BEGIN

    RULE                 "Extreme Drought per Water Sharing Agreement";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    BEGIN

      IF_STATEMENT ($ "Navajo.Pool Elevation" [] <= $ "SanJuanNMWaterSharing.ProtectedPE" []) THEN
            $ "Navajo.Outflow" [] := $ "NavajoData.BaseRelease" [];

            $ "NavajoResults.ExtremeDroughtFlag" [] := 1.00000000;

            FOREACH (OBJECT obj IN "ListSubbasin"( "Water Sharing Agreement Users" ) SET_INTERSECTION "ListSubbasin"( "WaterUser" )) DO
            obj & "Depletion Requested" [] := 0.00000000 "acre-ft/month";

            obj & "Diversion Requested" [] := 0.00000000 "acre-ft/month";

      ENDFOREACH;

      END_IF_STATEMENT;

    END;

    RULE                 "Dam Protection Flood Control";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    BEGIN

      IF_STATEMENT ($ "Navajo.Pool Elevation" [] > $ "NavajoData.MaxPE" []) THEN
            $ "Navajo.Outflow" [] := $ "Navajo.Outflow" [] + "VolumeToFlow"( "ElevationToStorage"( % "Navajo", $ "Navajo.Pool Elevation" [] ) - "ElevationToStorage"( % "Navajo", $ "NavajoData.PostDamProtectionPE" [] ), @"t" );

            $ "NavajoResults.DamProtectionFlag" [] := 1.00000000;

            $ "NavajoResults.VolumeReleasedForDamProtection" [] := "ElevationToStorage"( % "Navajo", $ "Navajo.Pool Elevation" [] ) - "ElevationToStorage"( % "Navajo", $ "NavajoData.PostDamProtectionPE" [] );

      END_IF_STATEMENT;

    END;

    RULE                 "Flow Recommendation Covered Flood Control";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" >= @"24:00:00 September 30, Current Year" AND @"t" <= @"24:00:00 December 31, Current Year";
    BEGIN

      IF_STATEMENT ($ "Navajo.Pool Elevation" [] > $ "NavajoData.MaxDesiredPE" []) THEN
            $ "Navajo.Outflow" [] := "Min"( $ "Navajo.Outflow" [] + "VolumeToFlow"( "ElevationToStorage"( % "Navajo", $ "Navajo.Pool Elevation" [] ) - "ElevationToStorage"( % "Navajo", $ "NavajoData.PostFloodControlPE" [] ), @"t" ), $ "NavajoData.SpringPeakRelease" [] ) COMMENTED_BY "The new outflow should either be the necesary outlfow to get the PE<br>to the desired height, or the full release of 5000 cfs all month- whichever<br>is less, since it can't spill at elevation 6,082'.  If this outflow is not enough <br>to keep it below 6,085' then the dam protection rule will allow for spill.";

            $ "NavajoResults.FloodControlFlag" [] := 1.00000000;

            $ "NavajoResults.FloodControlVolume" [] := "Min"( "ElevationToStorage"( % "Navajo", $ "Navajo.Pool Elevation" [] ) - "ElevationToStorage"( % "Navajo", $ "NavajoData.PostFloodControlPE" [] ), "FlowToVolume"( $ "NavajoData.SpringPeakRelease" [] - $ "Navajo.Outflow" [], @"t" ) );

      END_IF_STATEMENT;

    END;

    RULE                 "Makeup for Shorted Diversion per Water Sharing Agreement";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 November Max DayOfMonth, Current Year" OR @"t" == @"24:00:00 December Max DayOfMonth, Current Year" AND NOT "HasRuleFiredSuccessfully"( "Makeup for Shorted Diversion per Water Sharing Agreement" );
    BEGIN

      IF_STATEMENT (( ( "IsWSAYear"(  ) AND $ "Navajo.Outflow" [] == $ "NavajoData.BaseRelease" [] AND $ "SanJuanNearBluff.Gage Inflow" [] > $ "NavajoData.MinTargetBaseflow" [] ) AND "SubbasinShortage"( "WSA Energy Farmington Jicarilla" COMMENTED_BY "Subbasin containing the four users", @"24:00:00 January Max DayOfMonth, Current Year", @"24:00:00 December Max DayOfMonth, Current Year" ) > 0.00000000 "acre-ft" ) COMMENTED_BY "If there was a WSA for the year and if Navajo is at base release while the min target <br>at Bluff is exceeded then, the San Juan Generating Station, Four Corners Power Plant, <br>City of Farmington and the minor Jicarilla Apache Nation subcontractors are allowed<br>to divert excess water to make up for the water they were shorted in the year") THEN
            FOREACH (OBJECT obj IN "ListSubbasin"( "WSA Energy Farmington Jicarilla" )) DO
            obj & "Depletion Requested" [] := "VolumeToFlow"( "Min"( "FlowToVolume"( $ "SanJuanNearBluff.Gage Inflow" [] - $ "NavajoData.MinTargetBaseflow" [], @"t" ) COMMENTED_BY "Water above 500 cfs available- must maintain min baseflow target at Bluff", "SubbasinShortage"( "WSA Energy Farmington Jicarilla" COMMENTED_BY "Subbasin containing the four users", @"24:00:00 January Max DayOfMonth, Current Year", @"24:00:00 December Max DayOfMonth, Current Year" ) COMMENTED_BY "The total shortage that all 4 above users incurred for the year" ) COMMENTED_BY "The water available to all four users" * ( WITH LIST objAndUser = "Split"( STRINGIFY obj, ":" ) DO
      ( "SumFlowsToVolume"( % "NM Schedules" & ( ( ( GET @INDEX 0.00000000 FROM objAndUser ) CONCAT "_" CONCAT GET @INDEX 1.00000000 FROM objAndUser ) CONCAT "_" CONCAT "Depletion Requested" ), @"24:00:00 January Max DayOfMonth, Current Year", @"24:00:00 December Max DayOfMonth, Current Year" ) - "SumFlowsToVolume"( obj & "Depletion Requested", @"24:00:00 January Max DayOfMonth, Current Year", @"24:00:00 December Max DayOfMonth, Current Year" ) )
   ENDWITH / "SubbasinShortage"( "WSA Energy Farmington Jicarilla" COMMENTED_BY "Subbasin containing the four users", @"24:00:00 January Max DayOfMonth, Current Year", @"24:00:00 December Max DayOfMonth, Current Year" ) ) COMMENTED_BY "The percentage of the current object compared with all other users", @"t" ) + obj & "Depletion Requested" [];

            obj & "Diversion Requested" [] := "VolumeToFlow"( "Min"( "FlowToVolume"( $ "SanJuanNearBluff.Gage Inflow" [] - $ "NavajoData.MinTargetBaseflow" [], @"t" ) COMMENTED_BY "Water above 500 cfs available- must maintain min baseflow target at Bluff", "SubbasinShortage"( "WSA Energy Farmington Jicarilla" COMMENTED_BY "Subbasin containing the four users", @"24:00:00 January Max DayOfMonth, Current Year", @"24:00:00 December Max DayOfMonth, Current Year" ) COMMENTED_BY "The total shortage that all 4 above users incurred for the year" ) COMMENTED_BY "The water available to all four users" * ( WITH LIST objAndUser = "Split"( STRINGIFY obj, ":" ) DO
      ( "SumFlowsToVolume"( % "NM Schedules" & ( ( ( GET @INDEX 0.00000000 FROM objAndUser ) CONCAT "_" CONCAT GET @INDEX 1.00000000 FROM objAndUser ) CONCAT "_" CONCAT "Depletion Requested" ), @"24:00:00 January Max DayOfMonth, Current Year", @"24:00:00 December Max DayOfMonth, Current Year" ) - "SumFlowsToVolume"( obj & "Depletion Requested", @"24:00:00 January Max DayOfMonth, Current Year", @"24:00:00 December Max DayOfMonth, Current Year" ) )
   ENDWITH / "SubbasinShortage"( "WSA Energy Farmington Jicarilla" COMMENTED_BY "Subbasin containing the four users", @"24:00:00 January Max DayOfMonth, Current Year", @"24:00:00 December Max DayOfMonth, Current Year" ) ) COMMENTED_BY "The percentage of the current object compared with all other users", @"t" ) * "DepletionToDiversionRatio"( ( STRINGIFY obj ) CONCAT ".Depletion Requested", ( STRINGIFY obj ) CONCAT ".Diversion Requested", @"t" ) + obj & "Diversion Requested" [];

      ENDFOREACH;

      END_IF_STATEMENT;

    END;

    RULE                 "Reduce Minimum Target Base Flow per Water Sharing Agreement";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" >= @"24:00:00 March Max DayOfMonth, Current Year" AND @"t" <= @"24:00:00 June Max DayOfMonth, Current Year";
    BEGIN

      IF_STATEMENT ($ "NavajoResults.ProjectedPE" [@"24:00:00 July Max DayOfMonth, Current Year"] < "StorageToElevation"( % "Navajo", $ "SanJuanNMWaterSharing.BaseflowReductionStorage" [] ) AND NOT "IsWSAYear"(  )) THEN
            FOREACH (DATETIME date IN @"t" TO @"24:00:00 October Max DayOfMonth, Current Year") DO
            $ "NavajoResults.CurrentTargetBaseflow" [date] := $ "SanJuanNMWaterSharing.ReducedTargetBaseflow" [];

      ENDFOREACH;

      END_IF_STATEMENT;

    END;

    RULE                 "Protect Elevation 5990 per Water Sharing Agreement - Original";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT ( NOT "HasRuleFiredSuccessfully"( "Protect Elevation 5990 per Water Sharing Agreement" ) ) COMMENTED_BY "Only allow this rule to fire once, since it has dependencies on slots it sets.  If it fires more <br>than once, it will short users too much";
    BEGIN

      IF_STATEMENT ($ "NavajoResults.WSAShortage" [] > 0.00000000 "acre-ft") THEN
            FOREACH (DATETIME date IN @"t" TO @"24:00:00 December Max DayOfMonth, Current Year") DO
            FOREACH (OBJECT obj IN "ListSubbasin"( "Water Sharing Agreement Users" ) SET_INTERSECTION "ListSubbasin"( "AggDiversionSite" )) DO
            obj & "Total Depletion Requested" [date] := "VolumeToFlow"( "ModifyDepletionSchedulesPerWSA"( obj, date ), date );

            obj & "Total Diversion Requested" [date] := "VolumeToFlow"( "ModifyDepletionSchedulesPerWSA"( obj, date ), date ) * IF ( obj == % "NewMexicoAgricultureSJUse" )
   THEN
      "DepletionToDiversionRatio"( "SanJuanNewMexicoDiversionSchedules.NewMexicoAgriculture_Depletion", "SanJuanNewMexicoDiversionSchedules.NewMexicoAgriculture_Diversion", date )
   ELSE
      "DepletionToDiversionRatio"( ( "SanJuanNewMexicoDiversionSchedules." CONCAT STRINGIFY obj ) CONCAT "_" CONCAT "Depletion", ( "SanJuanNewMexicoDiversionSchedules." CONCAT STRINGIFY obj ) CONCAT "_" CONCAT "Diversion", date )
   ENDIF;

      ENDFOREACH;

            IF_STATEMENT (date >= @"24:00:00 March Max DayOfMonth, Current Year" AND date <= @"24:00:00 October Max DayOfMonth, Current Year") THEN
            $ "NavajoResults.CurrentTargetBaseflow" [date] := "Max"( $ "NavajoResults.CurrentTargetBaseflow" [] * ( 1.00000000 - $ "NavajoResults.WSAPercentageReduction" [] ), $ "SanJuanNMWaterSharing.MinReducedBaseflow" [] );

      END_IF_STATEMENT;

      ENDFOREACH;

      END_IF_STATEMENT;

    END;

    RULE                 "Protect Elevation 5990 per Water Sharing Agreement- RAND";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT ( NOT "HasRuleFiredSuccessfully"( "Protect Elevation 5990 per Water Sharing Agreement" ) ) COMMENTED_BY "Only allow this rule to fire once, since it has dependencies on slots it sets.  If it fires more <br>than once, it will short users too much";
    BEGIN

      IF_STATEMENT ($ "NavajoResults.WSAShortage" [] > 0.00000000 "acre-ft") THEN
            FOREACH (DATETIME date IN @"t" TO @"24:00:00 December Max DayOfMonth, Current Year") DO
            FOREACH (OBJECT obj IN "ListSubbasin"( "Water Sharing Agreement Users" ) SET_INTERSECTION "ListSubbasin"( "WaterUser" )) DO
            obj & "Depletion Requested" [date] := "VolumeToFlow"( "ModifyDepletionSchedulesPerWSA"( obj, date ), date ) * "SJSchedulesUserToAggDivRatio"( WITH LIST aggAndWU = "Split"( STRINGIFY obj, ":" ) DO
      ( ( GET @INDEX 0.00000000 FROM aggAndWU ) CONCAT "_" CONCAT GET @INDEX 1.00000000 FROM aggAndWU ) CONCAT "_Depletion"
   ENDWITH, date );

            obj & "Diversion Requested" [date] := WITH LIST aggAndWU = "Split"( STRINGIFY obj, ":" ) DO
      "VolumeToFlow"( "ModifyDepletionSchedulesPerWSA"( obj, date ), date ) * "SJSchedulesUserToAggDivRatio"( ( ( GET @INDEX 0.00000000 FROM aggAndWU ) CONCAT "_" CONCAT GET @INDEX 1.00000000 FROM aggAndWU ) CONCAT "_Depletion", date ) * "NMSJDepletionToDiversionRatio"( ( GET @INDEX 0.00000000 FROM aggAndWU ) CONCAT "_" CONCAT GET @INDEX 1.00000000 FROM aggAndWU, date )
   ENDWITH;

      ENDFOREACH;

            IF_STATEMENT (date >= @"24:00:00 March Max DayOfMonth, Current Year" AND date <= @"24:00:00 October Max DayOfMonth, Current Year") THEN
            $ "NavajoResults.CurrentTargetBaseflow" [date] := "Max"( $ "NavajoResults.CurrentTargetBaseflow" [] * ( 1.00000000 - $ "NavajoResults.WSAPercentageReduction" [] ), $ "SanJuanNMWaterSharing.MinReducedBaseflow" [] );

      END_IF_STATEMENT;

      ENDFOREACH;

      END_IF_STATEMENT;

    END;

    RULE                 "Protect Elevation 5990 per Water Sharing Agreement";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( NOT "HasRuleFiredSuccessfully"( "Protect Elevation 5990 per Water Sharing Agreement" ) ) COMMENTED_BY "Only allow this rule to fire once, since it has dependencies on slots it sets.  If it fires more <br>than once, it will short users too much";
    BEGIN

      IF_STATEMENT ($ "NavajoResults.WSAShortage" [] > 0.00000000 "acre-ft") THEN
            FOREACH (DATETIME date IN @"t" TO @"24:00:00 December Max DayOfMonth, Current Year") DO
            FOREACH (OBJECT obj IN "ListSubbasin"( "Water Sharing Agreement Users" ) SET_INTERSECTION "ListSubbasin"( "WaterUser" )) DO
            obj & "Depletion Requested" [date] := "VolumeToFlow"( "ModifyDepletionSchedulesPerWSA"( obj, date ), date );

            obj & "Diversion Requested" [date] := WITH LIST aggAndWU = "Split"( STRINGIFY obj, ":" ) DO
      "VolumeToFlow"( "ModifyDepletionSchedulesPerWSA"( obj, date ), date ) * "NMSJDepletionToDiversionRatio"( ( GET @INDEX 0.00000000 FROM aggAndWU ) CONCAT "_" CONCAT GET @INDEX 1.00000000 FROM aggAndWU, date )
   ENDWITH;

      ENDFOREACH;

            IF_STATEMENT (date >= @"24:00:00 March Max DayOfMonth, Current Year" AND date <= @"24:00:00 October Max DayOfMonth, Current Year") THEN
            $ "NavajoResults.CurrentTargetBaseflow" [date] := "Max"( $ "NavajoResults.CurrentTargetBaseflow" [] * ( 1.00000000 - $ "NavajoResults.WSAPercentageReduction" [] ), $ "SanJuanNMWaterSharing.MinReducedBaseflow" [] );

      END_IF_STATEMENT;

      ENDFOREACH;

      END_IF_STATEMENT;

    END;

    RULE                 "Determine Water Sharing Agreement Percentage Reduction";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Determine Water Sharing Agreement Percentage Reduction" );
    BEGIN

      $ "NavajoResults.WSAPercentageReduction" [] := "Min"( "Ceiling"( $ "NavajoResults.WSAShortage" [] / ( "SumFlowsToVolume"( $ "NewMexicoAgricultureArchToFarm.Total Depletion Requested", @"24:00:00 January Max DayOfMonth, Current Year", @"24:00:00 December Max DayOfMonth, Current Year" ) + "SumFlowsToVolume"( $ "NewMexicoAgFarmToShip.Total Depletion Requested", @"24:00:00 January Max DayOfMonth, Current Year", @"24:00:00 December Max DayOfMonth, Current Year" ) + "SumFlowsToVolume"( $ "NavajoIndianIrrigationProjectNIIPandExports.Total Diversion Requested", @"24:00:00 January Max DayOfMonth, Current Year", @"24:00:00 December Max DayOfMonth, Current Year" ) + ( "Max"( "SumFlowsToVolume"( $ "SanJuanRiverEnergyAndMIFarmToShip.Total Depletion Requested", @"24:00:00 January Max DayOfMonth, Current Year", @"24:00:00 December Max DayOfMonth, Current Year" ) - $ "SanJuanNMWaterSharing.EnergyVoluntaryReduction" [@"24:00:00 December Max DayOfMonth, Current Year"], 0.00000000 "acre-ft" ) + "SumFlowsToVolume"( $ "NewMexicoMiscellaneousUsesArchToFarm.Total Depletion Requested", @"24:00:00 January Max DayOfMonth, Current Year", @"24:00:00 December Max DayOfMonth, Current Year" ) ) + "CalcFutureSupplementalReleaseVolume"( $ "NavajoResults.PeakReleaseLevel" [IF ( @"t" > @"24:00:00 June Max DayOfMonth, Current Year" )
   THEN
      @"24:00:00 June Max DayOfMonth, Current Year"
   ELSE
      @"t"
   ENDIF], @"24:00:00 October 31, Current Year" ) COMMENTED_BY "Volume of fish flow from March 1 to October 31" ), 0.01000000 ), 1.00000000 COMMENTED_BY "Can only reduce up to 100 % of the use so contrain this calculation" );

    END;

    RULE                 "Determine Water Sharing Agreement Shortage";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT IsNaN $ "NavajoResults.WSAShortage" [];
    BEGIN

      IF_STATEMENT (( $ "Navajo.Pool Elevation" [] < $ "SanJuanNMWaterSharing.ProtectedPE" [] OR "IsFuturePELessThanProtectedPE"(  ) ) COMMENTED_BY "The current PE has this months PE after 'normal' operations.  If this PE<br>or any future PE is less than the protected PE then we must protect this<br>PE by reducing depletions.") THEN
            $ "NavajoResults.WSAShortage" [] := "ElevationToStorage"( % "Navajo", $ "SanJuanNMWaterSharing.ProtectedPE" [] ) - "ElevationToStorage"( % "Navajo", IF ( @"t" == @"24:00:00 December Max DayOfMonth, Current Year" )
   THEN
      $ "Navajo.Pool Elevation" [] COMMENTED_BY "If it is December, no other projected elevations exist"
   ELSE
      "MinItem"( INSERT $ "Navajo.Pool Elevation" [] INTO "GetSlotValsByCol"( $ "NavajoResults.ProjectedPE", @"t + 1", @"24:00:00 December Max DayOfMonth, Current Year", 0.00000000 ) ) COMMENTED_BY "Find the minPE from the current PE based on normal operations <br>and all projected PE's through October"
   ENDIF );

      ELSE
            $ "NavajoResults.WSAShortage" [] := 0.00000000 "acre-ft";

      END_IF_STATEMENT;

    END;

    RULE                 "Project Elevations for the Water Sharing Agreement";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( ( @"t" >= @"24:00:00 January Max DayOfMonth, Current Year" AND @"t" <= @"24:00:00 October Max DayOfMonth, Current Year" ) AND NOT "HasRuleFiredSuccessfully"( "Project Elevations for the Water Sharing Agreement" ) ) COMMENTED_BY "While we need to monitor the PE through October, this rule will only execute through September<br>since in October we won't have to 'project' the PE.  We will know it from base operations and<br>can check it in the Protect Elevation 5990 rule";
    BEGIN

      FOREACH (DATETIME date IN @"t + 1" COMMENTED_BY "t+1 because we do not need to project the PE of the current timestep,<br>we already know what it is from base operations" TO @"24:00:00 December Max DayOfMonth, Current Year") DO
            $ "NavajoResults.ProjectedPE" [date] := "ProjectedNavajoPE"( IF ( ( @"t" > @"24:00:00 June Max DayOfMonth, Current Year" ) COMMENTED_BY "Peak release level is only set up until June, so we must access <br>that slot if we are after June" )
   THEN
      $ "NavajoResults.PeakReleaseLevel" [@"24:00:00 June Max DayOfMonth, Current Year"]
   ELSE
      $ "NavajoResults.PeakReleaseLevel" [@"t"]
   ENDIF, date );

      ENDFOREACH;

    END;

    RULE                 "Extend Spring Peak Release for PE Control";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT IsNaN $ "NavajoResults.TotalSpringPeakExtensionDays" [];
    BEGIN

      IF_STATEMENT (( @"t" == @"24:00:00 March Max DayOfMonth, Current Year" AND $ "NavajoResults.TotalSpringPeakExtensionDays" [] + $ "NavajoData.ExtendedMaxHydrographData" [$ "NavajoResults.ExtendedSpringFlowIndex" [], 7.00000000] COMMENTED_BY "Days ramping up for extended bench" - $ "NavajoData.ExtendedMaxHydrographData" [$ "NavajoResults.ExtendedSpringFlowIndex" [], 5.00000000] COMMENTED_BY "Available days in April" - $ "NavajoData.ExtendedMaxHydrographData" [$ "NavajoResults.ExtendedSpringFlowIndex" [], 6.00000000] COMMENTED_BY "Available days in May" > 0.00000000 "day" ) COMMENTED_BY "If we are in March and the total number of extended days is greater than the<br>number of days in April then update March's release.") THEN
            $ "Navajo.Outflow" [] := "ExtendedSpringPeakRelease"(  );

      END_IF_STATEMENT;

      IF_STATEMENT (( @"t" == @"24:00:00 April Max DayOfMonth, Current Year" AND $ "NavajoResults.TotalSpringPeakExtensionDays" [] + $ "NavajoData.ExtendedMaxHydrographData" [$ "NavajoResults.ExtendedSpringFlowIndex" [], 7.00000000] COMMENTED_BY "Days ramping up for extended bench" - $ "NavajoData.ExtendedMaxHydrographData" [$ "NavajoResults.ExtendedSpringFlowIndex" [], 6.00000000] COMMENTED_BY "Available days in May" > 0.00000000 "day" ) COMMENTED_BY "If we are in April and the total number of extended days is greater than the<br>number of days in May then update March's release.") THEN
            $ "Navajo.Outflow" [] := "ExtendedSpringPeakRelease"(  );

      END_IF_STATEMENT;

      IF_STATEMENT (( @"t" == @"24:00:00 May Max DayOfMonth, Current Year" AND $ "NavajoResults.TotalSpringPeakExtensionDays" [] > 0.00000000 "day" ) COMMENTED_BY "If we are in May and total extension days is > 0 then update release.") THEN
            $ "Navajo.Outflow" [] := "ExtendedSpringPeakRelease"(  );

      END_IF_STATEMENT;

      IF_STATEMENT (@"t" == @"24:00:00 June Max DayOfMonth, Current Year") THEN
            $ "Navajo.Outflow" [] := "VolumeToFlow"( "JuneJulyModifiedReleaseVolume"(  ), @"t" );

      END_IF_STATEMENT;

      IF_STATEMENT (@"t" == @"24:00:00 July Max DayOfMonth, Current Year" AND $ "NavajoData.SpringPeakJuneJulyExtData" [$ "NavajoResults.PeakReleaseLevel" [@"24:00:00 June Max DayOfMonth, Current Year"] - 1.00000000, 4.00000000] COMMENTED_BY "Days at normal peak in June" + $ "NavajoResults.TotalSpringPeakExtensionDays" [@"24:00:00 June Max DayOfMonth, Current Year"] COMMENTED_BY "Total extended peak days " + $ "NavajoData.SpringPeakJuneJulyExtData" [$ "NavajoResults.PeakReleaseLevel" [@"24:00:00 June Max DayOfMonth, Current Year"] - 1.00000000, 3.00000000] COMMENTED_BY "days ramping down" > "GetDaysInMonth"( @"24:00:00 June Max DayOfMonth, Current Year" )) THEN
            $ "Navajo.Outflow" [] := "VolumeToFlow"( "JuneJulyModifiedReleaseVolume"(  ), @"t" );

      END_IF_STATEMENT;

    END;

    RULE                 "Determine if Spring Peak Extension is Required";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" >= @"24:00:00 March Max DayOfMonth, Current Year" AND @"t" <= @"24:00:00 July Max DayOfMonth, Current Year";
    BEGIN

      IF_STATEMENT (@"t" == @"24:00:00 March Max DayOfMonth, Current Year" AND $ "NavajoResults.PeakReleaseLevel" [] == 4.00000000 AND $ "NavajoResults.ProjectedEOWYPE" [] > $ "NavajoData.EOWYTargetPE" []) THEN
            $ "NavajoResults.TotalSpringPeakExtensionDays" [] := "Floor"( GET @INDEX 1.00000000 FROM "ExtendedSpringPeakDaysAndRate"( ( "AdditionalPeakVolume"(  ) + $ "NavajoData.SpringPeakReleaseData" [4.00000000, 5.00000000] + $ "NavajoData.SpringPeakReleaseData" [4.00000000, 6.00000000] ) COMMENTED_BY "Additional volume to reach EOWY PE + April and May<br>Volume from Max hydrograph is the total volume we<br>need to release with the new extended peak hydrograph<br>in March through May" ), 1.00000000 "day" ) COMMENTED_BY "Returns the total days needed.  This could be greater than available days at the <br>given rate, if the rate is the max of 5000 cfs.  Check for this in the subsequent rule.";

            $ "NavajoResults.ExtendedSpringFlow" [] := GET @INDEX 0.00000000 FROM "ExtendedSpringPeakDaysAndRate"( "AdditionalPeakVolume"(  ) + $ "NavajoData.SpringPeakReleaseData" [4.00000000, 5.00000000] + $ "NavajoData.SpringPeakReleaseData" [4.00000000, 6.00000000] );

            $ "NavajoResults.ExtendedSpringFlowIndex" [] := GET @INDEX 2.00000000 FROM "ExtendedSpringPeakDaysAndRate"( "AdditionalPeakVolume"(  ) + $ "NavajoData.SpringPeakReleaseData" [4.00000000, 5.00000000] + $ "NavajoData.SpringPeakReleaseData" [4.00000000, 6.00000000] );

      END_IF_STATEMENT;

      IF_STATEMENT (( @"t" == @"24:00:00 April Max DayOfMonth, Current Year" OR @"t" == @"24:00:00 May Max DayOfMonth, Current Year" ) COMMENTED_BY "In April and May, set the days and extended bench release equal to that calculated in March.<br>Since we have 'perfect' knowledge of the inflow and anticipated release, there should be little<br>difference in the calculations from March to April/May.  However, the method of determining <br>the additional volume necessary to release would need to be changed if the calculation <br>were to be perfromed in April and/or May." AND NOT IsNaN $ "NavajoResults.TotalSpringPeakExtensionDays" [@"24:00:00 March Max DayOfMonth, Current Year"]) THEN
            $ "NavajoResults.TotalSpringPeakExtensionDays" [] := $ "NavajoResults.TotalSpringPeakExtensionDays" [@"24:00:00 March Max DayOfMonth, Current Year"];

            $ "NavajoResults.ExtendedSpringFlow" [] := $ "NavajoResults.ExtendedSpringFlow" [@"24:00:00 March Max DayOfMonth, Current Year"];

            $ "NavajoResults.ExtendedSpringFlowIndex" [] := $ "NavajoResults.ExtendedSpringFlowIndex" [@"24:00:00 March Max DayOfMonth, Current Year"];

      END_IF_STATEMENT;

      IF_STATEMENT (@"t" == @"24:00:00 June Max DayOfMonth, Current Year" AND $ "NavajoResults.PeakReleaseLevel" [] > 0.00000000 AND $ "NavajoResults.ProjectedEOWYPE" [] > $ "NavajoData.EOWYTargetPE" []) THEN
            IF_STATEMENT (( "AdditionalPeakVolume"(  ) > ( $ "NavajoData.SpringPeakRelease" [] * 1.00000000 "day" ) COMMENTED_BY "1 day at 5000 cfs" ) COMMENTED_BY "Only want to extend 5000 cfs if the necessary additional volume to <br>meet the EOWY target elevation is greater than the volume released<br>for one day at 5000 cfs") THEN
            $ "NavajoResults.TotalSpringPeakExtensionDays" [] := "Floor"( "ExtraJuneJulyDaysAtPeak"( "AdditionalPeakVolume"(  ) ), 1.00000000 "day" ) COMMENTED_BY "The total days necessary to release additional volume.  Could be more<br>than the available days";

            $ "NavajoResults.ExtendedSpringFlow" [] := $ "NavajoData.SpringPeakRelease" [] COMMENTED_BY "Always equal to 5000 cfs, since we are not trying to extend different benches";

      END_IF_STATEMENT;

      END_IF_STATEMENT;

      IF_STATEMENT (@"t" == @"24:00:00 July Max DayOfMonth, Current Year" AND NOT IsNaN $ "NavajoResults.TotalSpringPeakExtensionDays" [@"24:00:00 June Max DayOfMonth, Current Year"]) THEN
            $ "NavajoResults.TotalSpringPeakExtensionDays" [] := $ "NavajoResults.TotalSpringPeakExtensionDays" [@"24:00:00 June Max DayOfMonth, Current Year"];

            $ "NavajoResults.ExtendedSpringFlow" [] := $ "NavajoResults.ExtendedSpringFlow" [@"24:00:00 June Max DayOfMonth, Current Year"];

      END_IF_STATEMENT;

    END;

    RULE                 "Spring Peak Release for Flow Recommendations";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "IsSpringPeakMonth"( % "Navajo", @"t" );
    BEGIN

      IF_STATEMENT (@"t" == @"24:00:00 April 30, Current Year" AND ( $ "NavajoResults.PeakReleaseLevel" [] == 4.00000000 ) COMMENTED_BY "Only need to increase release volume in April if it is the max hydrograph") THEN
            $ "Navajo.Outflow" [] := "Min"( ( ( "FlowToVolume"( $ "Navajo.Outflow" [], @"t" ) + "MonthlySpringReleaseVolume"(  ) ) / "GetDaysInMonth"( @"t" ) ), "AvailableWaterInStorage"( % "Navajo" ) ) COMMENTED_BY "Increase the current monthly release volume by the spring release volume amount <br>then change back to a flow by dividing by days in month";

      ELSE
            IF_STATEMENT (@"t" > @"24:00:00 April 30, Current Year" AND ( $ "NavajoResults.PeakReleaseLevel" [] > 0.00000000 ) COMMENTED_BY "Only need to increase release volume if there is a spring peak release") THEN
            $ "Navajo.Outflow" [] := "Min"( ( "FlowToVolume"( $ "Navajo.Outflow" [], @"t" ) + "MonthlySpringReleaseVolume"(  ) ) / "GetDaysInMonth"( @"t" ), "AvailableWaterInStorage"( % "Navajo" ) );

      END_IF_STATEMENT;

      END_IF_STATEMENT;

    END;

    RULE                 "Set Projected EOWY Pool Elevation";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" >= @"24:00:00 January 31, Current Year" AND @"t" <= @"24:00:00 June 30, Current Year" AND ( IsNaN $ "NavajoResults.ProjectedEOWYPE" [] ) COMMENTED_BY "Only allow rule to fire once each timestep";
    BEGIN

      IF_STATEMENT (@"t" == @"24:00:00 June 30, Current Year") THEN
            $ "NavajoResults.ProjectedEOWYPE" [] := WITH NUMERIC val = "DeterminePeakRelease"(  ) DO
      IF ( val == $ "NavajoResults.PeakReleaseLevel" [@"t - 1"] )
      THEN
         "ProjectedNavajoPE"( val, @"24:00:00 September Max DayOfMonth, Current Year" )
      ELSE
         IF ( val > 0.00000000 )
         THEN
            "ProjectedNavajoPE"( val, @"24:00:00 September Max DayOfMonth, Current Year" )
         ELSE
            "ProjectedNavajoPE"( 1.00000000, @"24:00:00 September Max DayOfMonth, Current Year" )
         ENDIF
      ENDIF
   ENDWITH;

      ELSE
            $ "NavajoResults.ProjectedEOWYPE" [] := "ProjectedNavajoPE"( "DeterminePeakRelease"(  ), @"24:00:00 September Max DayOfMonth, Current Year" );

      END_IF_STATEMENT;

    END;

    RULE                 "Set Peak Release Level";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" >= @"24:00:00 January Max DayOfMonth, Current Year" AND @"t" <= @"24:00:00 July Max DayOfMonth, Current Year" AND ( IsNaN $ "NavajoResults.PeakReleaseLevel" [] ) COMMENTED_BY "Only allow rule to fire once each timestep";
    BEGIN

      IF_STATEMENT (@"t" == @"24:00:00 June 30, Current Year") THEN
            $ "NavajoResults.PeakReleaseLevel" [] := WITH NUMERIC val = "DeterminePeakRelease"(  ) DO
      IF ( val == $ "NavajoResults.PeakReleaseLevel" [@"t - 1"] )
      THEN
         val
      ELSE
         IF ( val > 0.00000000 )
         THEN
            val
         ELSE
            1.00000000
         ENDIF
      ENDIF
   ENDWITH COMMENTED_BY "In June, allow the peak release to change release patterns.  However, if a peak <br>release has started then there will at least be some peak release.  So, the <br>pattern cannot change from 1-4 to a 0, but any other changes are allowed.";

      ELSE
            IF_STATEMENT (@"t" == @"24:00:00 July Max DayOfMonth, Current Year") THEN
          DESCRIPTION          "Set equal to June's.  Only sets July so that other function and rules can use july's value<br>as this will not dictate any operations";
      $ "NavajoResults.PeakReleaseLevel" [] := $ "NavajoResults.PeakReleaseLevel" [@"t - 1"];

      ELSE
          DESCRIPTION          "So any changes are allowed from April to May.  Can go from a max hydrograph to any <br>other.  So there will be a small increase in release in April and then a ramp back down in<br>May and another ramp up period in May.";
      $ "NavajoResults.PeakReleaseLevel" [] := "DeterminePeakRelease"(  );

      END_IF_STATEMENT;

      END_IF_STATEMENT;

    END;

    RULE                 "Compute Forecasted Inflow";
    DESCRIPTION          "Currently there is no forecast error in the model, thus the forecasted inflow is the actual inflow that Navajo will receive.<br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" >= @"24:00:00 January 31, Current Year" AND @"t" <= @"24:00:00 October 31, Current Year";
    BEGIN

      FOREACH (DATETIME date IN @"t" TO @"24:00:00 December 31, Current Year") DO
            $ "NavajoData.ForecastedInflow" [date] := $ "Navajo.Inflow" [date];

      ENDFOREACH;

    END;

    RULE                 "Short NIIP";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT ( NOT "HasRuleFiredSuccessfully"( "Short NIIP" ) ) COMMENTED_BY "Only allow rule to fire successfully once each timestep";
    BEGIN

      IF_STATEMENT ($ "Navajo.Pool Elevation" [] < $ "SanJuanNMWaterSharing.ProtectedPE" []) THEN
            $ "NavajoIndianIrrigationProjectNIIP:NIIP.Diversion Requested" [] := "Max"( $ "NavajoIndianIrrigationProjectNIIP:NIIP.Diversion Requested" [] - "VolumeToFlow"( "ElevationToStorage"( % "Navajo", $ "SanJuanNMWaterSharing.ProtectedPE" [] ) - $ "Navajo.Storage" [], @"t" ), 0.00000000 "acre-ft/month" );

            $ "NavajoIndianIrrigationProjectNIIP:NIIP.Depletion Requested" [] := "Max"( ( $ "NavajoIndianIrrigationProjectNIIP:NIIP.Diversion Requested" [] - "VolumeToFlow"( "ElevationToStorage"( % "Navajo", $ "SanJuanNMWaterSharing.ProtectedPE" [] ) - $ "Navajo.Storage" [], @"t" ) ) * "NIIPDiversionRatio"(  ), 0.00000000 "acre-ft/month" );

      END_IF_STATEMENT;

    END;

    RULE                 "Supplement Base Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT IsNaN $ "NavajoResults.SupplementalRelease" [];
    BEGIN

      IF_STATEMENT ($ "SanJuanNearBluff.Gage Inflow" [] < $ "NavajoResults.CurrentTargetBaseflow" [] OR FOR ( OBJECT obj IN "ListSubbasin"( "NMDemandsBelowSanJuanSJTribsConf" ) SET_INTERSECTION "ListSubbasin"( "AggDiversionSite" ) ) WITH NUMERIC result = 0.00000000 "acre-ft/month" DO
      "Max"( result, obj & "Total Diversion Requested" [] - obj & "Total Diversion" [] )
   ENDFOR COMMENTED_BY "It is possible that the flow is higher than the minimum at Bluff but a diverter might not receive <br>its full diversion.  In this case, Navajo should release to ensure the user gets its full diversion" > 0.00000000 "acre-ft/month") THEN
            $ "Navajo.Outflow" [] := "Min"( $ "NavajoData.BaseRelease" [] + "Ceiling"( "Max"( ( $ "NavajoResults.CurrentTargetBaseflow" [] - $ "SanJuanNearBluff.Gage Inflow" [] ), FOR ( OBJECT obj IN "ListSubbasin"( "NMDemandsBelowSanJuanSJTribsConf" ) SET_INTERSECTION "ListSubbasin"( "AggDiversionSite" ) ) WITH NUMERIC result = 0.00000000 "acre-ft/month" DO
      "Max"( result, obj & "Total Diversion Requested" [] - obj & "Total Diversion" [] )
   ENDFOR ), $ "NavajoData.SupplementalReleaseIncrement" [] ) COMMENTED_BY "Rounds the supplemental release up to the nearest SupplementalReleaseIncrement", "AvailableWaterInStorage"( % "Navajo" ) );

            $ "NavajoResults.SupplementalRelease" [] := "Ceiling"( "Max"( ( $ "NavajoResults.CurrentTargetBaseflow" [] - $ "SanJuanNearBluff.Gage Inflow" [] ), FOR ( OBJECT obj IN "ListSubbasin"( "NMDemandsBelowSanJuanSJTribsConf" ) SET_INTERSECTION "ListSubbasin"( "AggDiversionSite" ) ) WITH NUMERIC result = 0.00000000 "acre-ft/month" DO
      "Max"( result, obj & "Total Diversion Requested" [] - obj & "Total Diversion" [] )
   ENDFOR ), $ "NavajoData.SupplementalReleaseIncrement" [] );

            $ "NavajoResults.SupplementalReleaseFlag" [] := IF ( ( $ "NavajoResults.CurrentTargetBaseflow" [] - $ "SanJuanNearBluff.Gage Inflow" [] ) > FOR ( OBJECT obj IN "ListSubbasin"( "NMDemandsBelowSanJuanSJTribsConf" ) SET_INTERSECTION "ListSubbasin"( "AggDiversionSite" ) ) WITH NUMERIC result = 0.00000000 "acre-ft/month" DO
      "Max"( result, obj & "Total Diversion Requested" [] - obj & "Total Diversion" [] )
   ENDFOR )
   THEN
      1.00000000 COMMENTED_BY "Set the flag to 1 to show the supplemental release was to meet the baseflow target at Bluff"
   ELSE
      2.00000000 COMMENTED_BY "Set the flag to 2 to show the supplemental release was to meet the all upstream diversions"
   ENDIF;

      ELSE
            $ "NavajoResults.SupplementalRelease" [] := 0.00000000 "cfs";

      END_IF_STATEMENT;

    END;

    RULE                 "Set Base Release";
    DESCRIPTION          "Aims to meet the target baseflow of 500-1000 cfs at the downstream gages from the flow recommendations by setting Navajo's release to the base releasee (currently 250 cfs which is the minimum release from Navajo per the ROD)";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    BEGIN

      $ "Navajo.Outflow" [] := "Min"( $ "NavajoData.BaseRelease" [], "AvailableWaterInStorage"( % "Navajo" ) );

    END;

    RULE                 "Set NIIP Schedule";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT TRUE;
    BEGIN

      FOREACH (DATETIME date IN @"t" TO @"t") DO
            $ "NavajoIndianIrrigationProjectNIIP:NIIP.Depletion Requested" COMMENTED_BY "Set NIIP's normal depletion schedule" [date] := IF ( "StorageToElevation"( % "Navajo", $ "Navajo.Storage" [@"t - 1"] + "FlowToVolume"( $ "Navajo.Inflow" [], @"t" ) ) < $ "SanJuanNMWaterSharing.ProtectedPE" [] )
   THEN
      0.00000000 "acre-ft/month"
   ELSE
      $ "SanJuanNewMexicoDiversionSchedules.NavajoIndianIrrigationProjectNIIP_Depletion" [date]
   ENDIF;

            $ "NavajoIndianIrrigationProjectNIIP:NIIP.Diversion Requested" [date] := IF ( "StorageToElevation"( % "Navajo", $ "Navajo.Storage" [@"t - 1"] + "FlowToVolume"( $ "Navajo.Inflow" [], @"t" ) ) < $ "SanJuanNMWaterSharing.ProtectedPE" [] )
   THEN
      0.00000000 "acre-ft/month"
   ELSE
      $ "SanJuanNewMexicoDiversionSchedules.NavajoIndianIrrigationProjectNIIP_Diversion" [date]
   ENDIF;

            $ "NavajoResults.DamProtectionFlag" COMMENTED_BY "Zero the following slots so that NaN's do not cause issues in other rules<br>" [date] := 0.00000000;

            $ "NavajoResults.FloodControlFlag" [date] := 0.00000000;

            $ "NavajoResults.FloodControlVolume" [date] := 0.00000000 "acre-ft";

            $ "NavajoResults.VolumeReleasedForDamProtection" [date] := 0.00000000 "acre-ft";

            $ "NavajoResults.ExtremeDroughtFlag" [date] := 0.00000000;

            $ "NavajoResults.CurrentTargetBaseflow" [date] := $ "NavajoData.MinTargetBaseflow" [];

            $ "NavajoResults.SupplementalReleaseFlag" [date] := 0.00000000;

      ENDFOREACH;

    END;

    RULE                 "Initialize Flags";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January 31, Current Year";
    BEGIN

      FOREACH (DATETIME date IN @"24:00:00 January 31, Current Year" TO @"24:00:00 December 31, Current Year") DO
            $ "NavajoResults.DamProtectionFlag" COMMENTED_BY "Zero the following slots so that NaN's do not cause issues in other rules<br>" [date] := 0.00000000;

            $ "NavajoResults.FloodControlFlag" [date] := 0.00000000;

            $ "NavajoResults.FloodControlVolume" [date] := 0.00000000 "acre-ft";

            $ "NavajoResults.VolumeReleasedForDamProtection" [date] := 0.00000000 "acre-ft";

            $ "NavajoResults.ExtremeDroughtFlag" [date] := 0.00000000;

            $ "NavajoResults.CurrentTargetBaseflow" [date] := $ "NavajoData.MinTargetBaseflow" [];

            $ "NavajoResults.SupplementalReleaseFlag" [date] := 0.00000000;

      ENDFOREACH;

    END;

  END;

  POLICY_GROUP   "Taylor Park and Aspinall Rules";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  BEGIN

    RULE                 "NEW Fulfilll Crystal Demand";
    DESCRIPTION          "This rule fires monthly if the Crystal release required to meet the rule curve is not enough to meet the downstream demands. This rule re-sets the storage for Morrow Point, Taylor Park and Blue Mesa that was set in the lower priority rules. ";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT IsNaN $ "Aspinall Operations.BlueMesaforDemandsFlag" [] AND ( $ "ComputedDemandsBelow.Crystal" [] - $ "Crystal.Outflow" [] > 1.00000000 "acre-feet/month" ) COMMENTED_BY "Execute if demands are greater than outflow required to meet rule curve.";
    BEGIN

      IF_STATEMENT ("ComputeStorageAtGivenOutflow"( % "BlueMesa", $ "BlueMesa.Outflow" [] + ( $ "ComputedDemandsBelow.Crystal" [] - $ "Crystal.Outflow" [] ) + $ "GunnisonRiverAboveCrystal:GainsAboveCrystal.Local Inflow Adjust" [] ) == "InactiveCapacity"( % "BlueMesa" ) AND "ComputeStorageAtGivenOutflow"( % "TaylorPark", ( $ "TaylorPark.Outflow" [] + $ "ComputedDemandsBelow.Crystal" [] - $ "Crystal.Outflow" [] - "VolumeToFlow"( ( $ "BlueMesa.Storage" [] ) - "InactiveCapacity"( % "BlueMesa" ), @"t" ) ) + $ "GunnisonRiverAboveCrystal:GainsAboveCrystal.Local Inflow Adjust" [] + $ "TaylorAboveBlueMesa:GainsAboveBlueMesa.Local Inflow Adjust" [] ) == "InactiveCapacity"( % "TaylorPark" )) THEN
            $ "TaylorPark.Outflow" COMMENTED_BY "If both Blue Mesa and Taylor Park will reach inactive capacity when<br>releasing for Crystal's demands, then Morrow Point supplements the flow.<br>" [] := "SolveOutflow"( % "TaylorPark", $ "TaylorPark.Inflow" [], "Min"( "LiveCapacity"( % "TaylorPark" ), "ComputeStorageAtGivenOutflow"( % "TaylorPark", ( $ "TaylorPark.Outflow" [] + $ "ComputedDemandsBelow.Crystal" [] - $ "Crystal.Outflow" [] - "VolumeToFlow"( ( $ "BlueMesa.Storage" [] ) - "InactiveCapacity"( % "BlueMesa" ), @"t" ) ) + $ "GunnisonRiverAboveCrystal:GainsAboveCrystal.Local Inflow Adjust" [] + $ "TaylorAboveBlueMesa:GainsAboveBlueMesa.Local Inflow Adjust" [] ) ), $ "TaylorPark.Storage" [@"t - 1"], @"t" );

            $ "temp.if1" [] := 1.00000000;

            $ "temp.if2" [] := 0.00000000;

            $ "temp.if3" [] := 0.00000000;

            $ "BlueMesa.Outflow" [] := "SolveOutflow"( % "BlueMesa", $ "BlueMesa.Inflow" [] + ( "SolveOutflow"( % "TaylorPark", $ "TaylorPark.Inflow" [], "Min"( "LiveCapacity"( % "TaylorPark" ), "ComputeStorageAtGivenOutflow"( % "TaylorPark", ( $ "TaylorPark.Outflow" [] + $ "ComputedDemandsBelow.Crystal" [] - $ "Crystal.Outflow" [] - "VolumeToFlow"( ( $ "BlueMesa.Storage" [] ) - "InactiveCapacity"( % "BlueMesa" ), @"t" ) ) + $ "GunnisonRiverAboveCrystal:GainsAboveCrystal.Local Inflow Adjust" [] + $ "TaylorAboveBlueMesa:GainsAboveBlueMesa.Local Inflow Adjust" [] ) ), $ "TaylorPark.Storage" [@"t - 1"], @"t" ) - $ "TaylorPark.Outflow" [] ), "ComputeStorageAtGivenOutflow"( % "BlueMesa", $ "BlueMesa.Outflow" [] + ( $ "ComputedDemandsBelow.Crystal" [] - $ "Crystal.Outflow" [] ) + $ "GunnisonRiverAboveCrystal:GainsAboveCrystal.Local Inflow Adjust" [] ), $ "BlueMesa.Storage" [@"t - 1"], @"t" );

            $ "MorrowPoint.Outflow" [] := "SolveOutflow"( % "MorrowPoint", "SolveOutflow"( % "BlueMesa", $ "BlueMesa.Inflow" [] + ( "SolveOutflow"( % "TaylorPark", $ "TaylorPark.Inflow" [], "Min"( "LiveCapacity"( % "TaylorPark" ), "ComputeStorageAtGivenOutflow"( % "TaylorPark", ( $ "TaylorPark.Outflow" [] + $ "ComputedDemandsBelow.Crystal" [] - $ "Crystal.Outflow" [] - "VolumeToFlow"( ( $ "BlueMesa.Storage" [] ) - "InactiveCapacity"( % "BlueMesa" ), @"t" ) ) + $ "GunnisonRiverAboveCrystal:GainsAboveCrystal.Local Inflow Adjust" [] + $ "TaylorAboveBlueMesa:GainsAboveBlueMesa.Local Inflow Adjust" [] ) ), $ "TaylorPark.Storage" [@"t - 1"], @"t" ) - $ "TaylorPark.Outflow" [] ), "ComputeStorageAtGivenOutflow"( % "BlueMesa", $ "BlueMesa.Outflow" [] + ( $ "ComputedDemandsBelow.Crystal" [] - $ "Crystal.Outflow" [] ) + $ "GunnisonRiverAboveCrystal:GainsAboveCrystal.Local Inflow Adjust" [] ), $ "BlueMesa.Storage" [@"t - 1"], @"t" ), "ComputeStorageAtGivenInOut"( % "MorrowPoint", ( $ "MorrowPoint.Outflow" [] + $ "ComputedDemandsBelow.Crystal" [] - $ "Crystal.Outflow" [] ) + $ "GunnisonRiverAboveCrystal:GainsAboveCrystal.Local Inflow Adjust" [], $ "MorrowPoint.Inflow" [] + "VolumeToFlow"( ( $ "BlueMesa.Storage" [] ) - "InactiveCapacity"( % "BlueMesa" ), @"t" ) + "VolumeToFlow"( ( $ "TaylorPark.Storage" [] ) - "InactiveCapacity"( % "TaylorPark" ), @"t" ) ), $ "MorrowPoint.Storage" [@"t - 1"], @"t" );

            $ "Crystal.Outflow" [] := $ "Crystal.Outflow" [] + ( "SolveOutflow"( % "MorrowPoint", "SolveOutflow"( % "BlueMesa", $ "BlueMesa.Inflow" [] + ( "SolveOutflow"( % "TaylorPark", $ "TaylorPark.Inflow" [], "Min"( "LiveCapacity"( % "TaylorPark" ), "ComputeStorageAtGivenOutflow"( % "TaylorPark", ( $ "TaylorPark.Outflow" [] + $ "ComputedDemandsBelow.Crystal" [] - $ "Crystal.Outflow" [] - "VolumeToFlow"( ( $ "BlueMesa.Storage" [] ) - "InactiveCapacity"( % "BlueMesa" ), @"t" ) ) + $ "GunnisonRiverAboveCrystal:GainsAboveCrystal.Local Inflow Adjust" [] + $ "TaylorAboveBlueMesa:GainsAboveBlueMesa.Local Inflow Adjust" [] ) ), $ "TaylorPark.Storage" [@"t - 1"], @"t" ) - $ "TaylorPark.Outflow" [] ), "ComputeStorageAtGivenOutflow"( % "BlueMesa", $ "BlueMesa.Outflow" [] + ( $ "ComputedDemandsBelow.Crystal" [] - $ "Crystal.Outflow" [] ) + $ "GunnisonRiverAboveCrystal:GainsAboveCrystal.Local Inflow Adjust" [] ), $ "BlueMesa.Storage" [@"t - 1"], @"t" ), "ComputeStorageAtGivenInOut"( % "MorrowPoint", ( $ "MorrowPoint.Outflow" [] + $ "ComputedDemandsBelow.Crystal" [] - $ "Crystal.Outflow" [] ) + $ "GunnisonRiverAboveCrystal:GainsAboveCrystal.Local Inflow Adjust" [], $ "MorrowPoint.Inflow" [] + "VolumeToFlow"( ( $ "BlueMesa.Storage" [] ) - "InactiveCapacity"( % "BlueMesa" ), @"t" ) + "VolumeToFlow"( ( $ "TaylorPark.Storage" [] ) - "InactiveCapacity"( % "TaylorPark" ), @"t" ) ), $ "MorrowPoint.Storage" [@"t - 1"], @"t" ) - $ "MorrowPoint.Outflow" [] );

      ELSE
            IF_STATEMENT ("ComputeStorageAtGivenOutflow"( % "BlueMesa", $ "BlueMesa.Outflow" [] + ( $ "ComputedDemandsBelow.Crystal" [] - $ "Crystal.Outflow" [] ) + $ "GunnisonRiverAboveCrystal:GainsAboveCrystal.Local Inflow Adjust" [] ) == "InactiveCapacity"( % "BlueMesa" )) THEN
            $ "TaylorPark.Outflow" [] := "SolveOutflow"( % "TaylorPark", $ "TaylorPark.Inflow" [], "Min"( "LiveCapacity"( % "TaylorPark" ), "ComputeStorageAtGivenOutflow"( % "TaylorPark", ( $ "TaylorPark.Outflow" [] + $ "ComputedDemandsBelow.Crystal" [] - $ "Crystal.Outflow" [] - "VolumeToFlow"( ( $ "BlueMesa.Storage" [] ) - "InactiveCapacity"( % "BlueMesa" ), @"t" ) ) + $ "GunnisonRiverAboveCrystal:GainsAboveCrystal.Local Inflow Adjust" [] + $ "TaylorAboveBlueMesa:GainsAboveBlueMesa.Local Inflow Adjust" [] ) ), $ "TaylorPark.Storage" [@"t - 1"], @"t" );

            $ "temp.if1" [] := 0.00000000;

            $ "temp.if2" [] := 1.00000000;

            $ "temp.if3" [] := 0.00000000;

            $ "BlueMesa.Outflow" [] := "SolveOutflow"( % "BlueMesa", $ "BlueMesa.Inflow" [] + ( "SolveOutflow"( % "TaylorPark", $ "TaylorPark.Inflow" [], "Min"( "LiveCapacity"( % "TaylorPark" ), "ComputeStorageAtGivenOutflow"( % "TaylorPark", ( $ "TaylorPark.Outflow" [] + $ "ComputedDemandsBelow.Crystal" [] - $ "Crystal.Outflow" [] - "VolumeToFlow"( ( $ "BlueMesa.Storage" [] ) - "InactiveCapacity"( % "BlueMesa" ), @"t" ) ) + $ "GunnisonRiverAboveCrystal:GainsAboveCrystal.Local Inflow Adjust" [] + $ "TaylorAboveBlueMesa:GainsAboveBlueMesa.Local Inflow Adjust" [] ) ), $ "TaylorPark.Storage" [@"t - 1"], @"t" ) - $ "TaylorPark.Outflow" [] ), "ComputeStorageAtGivenOutflow"( % "BlueMesa", $ "BlueMesa.Outflow" [] + ( $ "ComputedDemandsBelow.Crystal" [] - $ "Crystal.Outflow" [] ) + $ "GunnisonRiverAboveCrystal:GainsAboveCrystal.Local Inflow Adjust" [] ), $ "BlueMesa.Storage" [@"t - 1"], @"t" );

            $ "MorrowPoint.Outflow" [] := "SolveOutflow"( % "MorrowPoint", "SolveOutflow"( % "BlueMesa", $ "BlueMesa.Inflow" [] + ( "SolveOutflow"( % "TaylorPark", $ "TaylorPark.Inflow" [], "Min"( "LiveCapacity"( % "TaylorPark" ), "ComputeStorageAtGivenOutflow"( % "TaylorPark", ( $ "TaylorPark.Outflow" [] + $ "ComputedDemandsBelow.Crystal" [] - $ "Crystal.Outflow" [] - "VolumeToFlow"( ( $ "BlueMesa.Storage" [] ) - "InactiveCapacity"( % "BlueMesa" ), @"t" ) ) + $ "GunnisonRiverAboveCrystal:GainsAboveCrystal.Local Inflow Adjust" [] + $ "TaylorAboveBlueMesa:GainsAboveBlueMesa.Local Inflow Adjust" [] ) ), $ "TaylorPark.Storage" [@"t - 1"], @"t" ) - $ "TaylorPark.Outflow" [] ), "ComputeStorageAtGivenOutflow"( % "BlueMesa", $ "BlueMesa.Outflow" [] + ( $ "ComputedDemandsBelow.Crystal" [] - $ "Crystal.Outflow" [] ) + $ "GunnisonRiverAboveCrystal:GainsAboveCrystal.Local Inflow Adjust" [] ), $ "BlueMesa.Storage" [@"t - 1"], @"t" ), $ "MorrowPoint.Storage" [], $ "MorrowPoint.Storage" [@"t - 1"], @"t" );

            $ "Crystal.Outflow" [] := $ "Crystal.Outflow" [] + ( "SolveOutflow"( % "BlueMesa", $ "BlueMesa.Inflow" [] + ( "SolveOutflow"( % "TaylorPark", $ "TaylorPark.Inflow" [], "Min"( "LiveCapacity"( % "TaylorPark" ), "ComputeStorageAtGivenOutflow"( % "TaylorPark", ( $ "TaylorPark.Outflow" [] + $ "ComputedDemandsBelow.Crystal" [] - $ "Crystal.Outflow" [] - "VolumeToFlow"( ( $ "BlueMesa.Storage" [] ) - "InactiveCapacity"( % "BlueMesa" ), @"t" ) ) + $ "GunnisonRiverAboveCrystal:GainsAboveCrystal.Local Inflow Adjust" [] + $ "TaylorAboveBlueMesa:GainsAboveBlueMesa.Local Inflow Adjust" [] ) ), $ "TaylorPark.Storage" [@"t - 1"], @"t" ) - $ "TaylorPark.Outflow" [] ), "ComputeStorageAtGivenOutflow"( % "BlueMesa", $ "BlueMesa.Outflow" [] + ( $ "ComputedDemandsBelow.Crystal" [] - $ "Crystal.Outflow" [] ) + $ "GunnisonRiverAboveCrystal:GainsAboveCrystal.Local Inflow Adjust" [] ), $ "BlueMesa.Storage" [@"t - 1"], @"t" ) - $ "BlueMesa.Outflow" [] );

      ELSE
            $ "BlueMesa.Outflow" COMMENTED_BY "Only Blue Mesa needs to increas flow to meet Crystal's demands,<br>thus Morrow Point and Crystal pass this amount of water.  " [] := "SolveOutflow"( % "BlueMesa", $ "BlueMesa.Inflow" [], "ComputeStorageAtGivenOutflow"( % "BlueMesa", $ "BlueMesa.Outflow" [] + ( $ "ComputedDemandsBelow.Crystal" [] - $ "Crystal.Outflow" [] ) + $ "GunnisonRiverAboveCrystal:GainsAboveCrystal.Local Inflow Adjust" [] ), $ "BlueMesa.Storage" [@"t - 1"], @"t" );

            $ "temp.if1" [] := 0.00000000;

            $ "temp.if2" [] := 0.00000000;

            $ "temp.if3" [] := 1.00000000;

            $ "MorrowPoint.Outflow" [] := "SolveOutflow"( % "MorrowPoint", "SolveOutflow"( % "BlueMesa", $ "BlueMesa.Inflow" [], "ComputeStorageAtGivenOutflow"( % "BlueMesa", $ "BlueMesa.Outflow" [] + ( $ "ComputedDemandsBelow.Crystal" [] - $ "Crystal.Outflow" [] ) + $ "GunnisonRiverAboveCrystal:GainsAboveCrystal.Local Inflow Adjust" [] ), $ "BlueMesa.Storage" [@"t - 1"], @"t" ), $ "MorrowPoint.Storage" [], $ "MorrowPoint.Storage" [@"t - 1"], @"t" );

            $ "Crystal.Outflow" [] := $ "Crystal.Outflow" [] + ( "SolveOutflow"( % "BlueMesa", $ "BlueMesa.Inflow" [], "ComputeStorageAtGivenOutflow"( % "BlueMesa", $ "BlueMesa.Outflow" [] + ( $ "ComputedDemandsBelow.Crystal" [] - $ "Crystal.Outflow" [] ) + $ "GunnisonRiverAboveCrystal:GainsAboveCrystal.Local Inflow Adjust" [] ), $ "BlueMesa.Storage" [@"t - 1"], @"t" ) - $ "BlueMesa.Outflow" [] );

      END_IF_STATEMENT;

      END_IF_STATEMENT;

      $ "Aspinall Operations.BlueMesaforDemandsFlag" [] := 1.00000000;

    END;

    RULE                 "Crystal Rule Curve";
    DESCRIPTION          "This rule fires monthly and sets the Crystal storage (only after Morrow Point and hence Blue Mesa are already set).  If the outflow required to get to the live capacity is greater than the maximum controlled release, then the storage is set assuming the maximum release.  If the outflow required to get to the live capacity is less than the minimum release (and the storage resulting from the minimum release isn't less than inactive capacity), then the storage is set assuming the minimum release.  If neither of these two extremes apply, then the storage is set to the rule curve storage, which is live capacity in this case. This rule is similiar as the rule Morrow Point Rule Curve.";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT IsNaN $ "MorrowPoint.Outflow" [] AND IsNaN $ "Crystal.Outflow" [];
    BEGIN

      $ "Crystal.Outflow" [] := "SolveOutflow"( % "Crystal", $ "Crystal.Inflow" [], "ComputeStorageAtGivenOutflow"( % "Crystal", "ComputeOutflowAtGivenStorage"( % "Crystal", "LiveCapacity"( % "Crystal" ) ) ), $ "Crystal.Storage" [@"t - 1"], @"t" );

    END;

    RULE                 "Morrow Point Rule Curve";
    DESCRIPTION          "This rule fires monthly and sets the Morrow Point storage (only if Blue Mesa is already set).  If the outflow required to get to the live capacity is greater than the maximum controlled release, then the storage is set assuming the maximum release.  If the outflow required to get to the live capacity is less than the minimum release (and the storage resulting from the minimum release isn't less than inactive capacity), then the storage is set assuming the minimum release.  If neither of these two extremes apply, then the storage is set to the rule curve storage, which is live capacity in this case.<br><br>In other words: make the reservoir full if you can within the physical constraints of release and capacity.<br><br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT IsNaN $ "MorrowPoint.Outflow" [] AND NOT IsNaN $ "BlueMesa.Outflow" [];
    BEGIN

      $ "MorrowPoint.Outflow" [] := "SolveOutflow"( % "MorrowPoint", $ "MorrowPoint.Inflow" [], "ComputeStorageAtGivenOutflow"( % "MorrowPoint", "ComputeOutflowAtGivenStorage"( % "MorrowPoint", "LiveCapacity"( % "MorrowPoint" ) ) ), $ "MorrowPoint.Storage" [@"t - 1"], @"t" );

    END;

    RULE                 "Blue Mesa Rule Curve";
    DESCRIPTION          "This rule fires monthly and sets the storage for Blue Mesa. It computes the storage based on the release to meet the target space for the month. A target space is used for Blue Mesa, (and also used for Navajo and Flaming Gorge) rather than the rule curve storage (used for the other Upper Basin reservoirs above Powell) and is modified during the simulation to simulate operations based on imperfect inflow forecasts.<br><br>An important thing to note here is that in the CRSS kludge in the ComputeTargetSpaceOutflow->TargetSpace->MaxAllowableStorage->CurrentInflowAbove function brings in the inflows and local inflows, therefore if they are negative, they will also be predicting negative flows as well.  Likely this is a bad thing.";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT IsNaN $ "BlueMesa.Outflow" [];
    BEGIN

      $ "BlueMesa.Outflow" [] := "SolveOutflow"( % "BlueMesa", $ "BlueMesa.Inflow" [], "ComputeStorageAtGivenOutflow"( % "BlueMesa", "ComputeTargetSpaceOutflow"( % "BlueMesa" ) ), $ "BlueMesa.Storage" [@"t - 1"], @"t" );

    END;

    RULE                 "Taylor Park Rule Curve";
    DESCRIPTION          "This rule fires monthly and sets the storage for Taylor Park. It computes the storage based on the whichever release demand is greater - the release to meet downstream demands (between Taylor Park and Blue Mesa) or the release to meet the storage rule curve.  <br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT IsNaN $ "TaylorPark.Outflow" [];
    BEGIN

      $ "TaylorPark.Outflow" [] := "SolveOutflow"( % "TaylorPark", $ "TaylorPark.Inflow" [], "ComputeStorageAtGivenOutflow"( % "TaylorPark", "Max"( "ComputeOutflowAtRuleCurveStorage"( % "TaylorPark" ), "ComputeDemandsBelow"( % "TaylorPark" ) ) ), $ "TaylorPark.Storage" [@"t - 1"], @"t" );

    END;

    RULE                 "Compute Demands Below Crystal";
    DESCRIPTION          "This rule fires monthly and sets a data object slot with the total monthly demand below the Crystal reservoir. The value is then used to compute the monthly storage for Morrow Point in the rule Fulfill Crystal Demand. It";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT IsNaN $ "ComputedDemandsBelow.Crystal" [];
    BEGIN

      $ "ComputedDemandsBelow.Crystal" [] := "ComputeDemandsBelow"( % "Crystal" );

    END;

  END;

  POLICY_GROUP   "Flaming Gorge";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  BEGIN

    RULE                 "Spill for PE Control";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    BEGIN

      IF_STATEMENT ($ "FlamingGorge.Pool Elevation" [] > $ "FlamingGorgeData.MaxPE" []) THEN
            $ "FlamingGorgeData.ManualSpill" [] := $ "FlamingGorgeData.ManualSpill" [] + "VolumeToFlow"( "ElevationToStorage"( % "FlamingGorge", $ "FlamingGorge.Pool Elevation" [] ) - "ElevationToStorage"( % "FlamingGorge", $ "FlamingGorgeData.MaxPE" [] ), @"t" );

            $ "FlamingGorge.Outflow" [] := $ "FlamingGorge.Outflow" [] + "VolumeToFlow"( "ElevationToStorage"( % "FlamingGorge", $ "FlamingGorge.Pool Elevation" [] ) - "ElevationToStorage"( % "FlamingGorge", $ "FlamingGorgeData.MaxPE" [] ), @"t" );

            $ "FlamingGorge.Bypass" [] := "Min"( $ "FlamingGorge.Bypass" [] + "VolumeToFlow"( "ElevationToStorage"( % "FlamingGorge", $ "FlamingGorge.Pool Elevation" [] ) - "ElevationToStorage"( % "FlamingGorge", $ "FlamingGorgeData.MaxPE" [] ), @"t" ), ( $ "FlamingGorgeData.BypassCapacity" [] - $ "FlamingGorgeData.PowerPlantCapacity" [] ) COMMENTED_BY "The actual bypass capacity, not counting the amount that can go through the power plant" );

      END_IF_STATEMENT;

    END;

    RULE                 "Min Flow in Extremely Dry Years with Low Storage";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "MonthIs"( { "January" , "February" , "March" , "April" , "August" , "September" , "October" , "November" , "December" } );
    BEGIN

      IF_STATEMENT ($ "FlamingGorge.Pool Elevation" [] < $ "FlamingGorgeData.MinReleaseTrigger" []) THEN
            $ "FlamingGorge.Outflow" [] := $ "FlamingGorgeData.AbsoluteMinRelease" [];

            $ "FlamingGorgeData.LowReleaseFlag" [] := 1.00000000;

      END_IF_STATEMENT;

    END;

    RULE                 "Spring Flow Operations";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "MonthIs"( { "May" , "June" , "July" } );
    BEGIN

      $ "FlamingGorge.Outflow" [] := $ "FlamingGorgeData.PreviousMonthProportion" [] * $ "FlamingGorge.Outflow" [@"t - 1"] + $ "FlamingGorgeData.RampUpProportion" [] * "AveRampUpFlow"(  ) + $ "FlamingGorgeData.BypassProportion" [] * $ "FlamingGorgeData.BypassCapacity" [] + $ "FlamingGorgeData.PPCProportion" [] * $ "FlamingGorgeData.PowerPlantCapacity" [] + $ "FlamingGorgeData.RampDownProportion" [] * "AveRampDownFlow"(  ) + $ "FlamingGorgeData.RemainingProportion" [] * "GetFGBaseFlowMagnitude"(  );

    END;

    RULE                 "Release to Meet ULDE";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "MonthIs"( { "March" , "April" } );
    BEGIN

    DESCRIPTION          "If it is March or April, then release whatever necessary to meet the May 1 ULDE";
      $ "FlamingGorge.Outflow" [] := IF ( "MonthIs"( { "March" } ) )
   THEN
      "Max"( ( "ElevationToStorage"( % "FlamingGorge", $ "FlamingGorge.Pool Elevation" [@"t - 1"] ) - "ElevationToStorage"( % "FlamingGorge", "GetMay1TargetElevation"(  ) ) + "PredictedFGInflow"( @"t", @"t + 1" ) ) / 2.00000000 "month", $ "FlamingGorgeData.MinFlow" [] )
   ELSE
      $ "FlamingGorge.Outflow" [@"t - 1"]
   ENDIF;

    END;

    RULE                 "Base Flow Operations";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "MonthIs"( { "March" , "April" , "May" } );
    BEGIN

      $ "FlamingGorge.Outflow" [] := "GetFGBaseFlowMagnitude"(  );

    END;

    RULE                 "Set Remaining Proportion";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "MonthIs"( { "May" , "June" , "July" } );
    BEGIN

      $ "FlamingGorgeData.RemainingProportion" [] := 1.00000000 - ( $ "FlamingGorgeData.PreviousMonthProportion" [] + $ "FlamingGorgeData.RampUpProportion" [] + $ "FlamingGorgeData.BypassProportion" [] + $ "FlamingGorgeData.PPCProportion" [] + $ "FlamingGorgeData.RampDownProportion" [] );

    END;

    RULE                 "Set Ramp Down Proportion";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "MonthIs"( { "May" , "June" , "July" } );
    BEGIN

      IF_STATEMENT ("MonthIs"( { "May" } )) THEN
            IF_STATEMENT ("PPCReleaseDidFinishInMay"(  )) THEN
            $ "FlamingGorgeData.RampDownProportion" [] := "RoundToNearestDay"( "DaysRemainingThisMonth"(  ) ) / "GetDaysInMonth"( @"t" );

      ELSE
            $ "FlamingGorgeData.RampDownProportion" [] := 0.00000000;

      END_IF_STATEMENT;

      END_IF_STATEMENT;

      IF_STATEMENT ("MonthIs"( { "June" , "July" } )) THEN
          DESCRIPTION          "Continue Downramp that was started in the previous month";
      IF_STATEMENT ($ "FlamingGorgeData.RampDownProportion" [@"t - 1"] > 0.00000000) THEN
          DESCRIPTION          "Only continue downramp if we didnt finish last month";
      IF_STATEMENT ($ "FlamingGorgeData.RemainingProportion" [@"t - 1"] > 0.00000000) THEN
            $ "FlamingGorgeData.RampDownProportion" [] := 0.00000000;

      ELSE
          DESCRIPTION          "It is possible that donramping took exactly the ramaining time <br>in the month so for the value to zero if it goes negative here";
      $ "FlamingGorgeData.RampDownProportion" [] := "Max"( ( "RoundToNearestDay"( "DaysToDownramp"(  ) ) - $ "FlamingGorgeData.RampDownProportion" [@"t - 1"] * "GetDaysInMonth"( @"t - 1" ) ) / "GetDaysInMonth"( @"t" ), 0.00000000 );

      END_IF_STATEMENT;

      ELSE
          DESCRIPTION          "Start Downramp which may or may not finish";
      IF_STATEMENT ("DaysRemainingThisMonth"(  ) > 0.00000000 "day" AND $ "FlamingGorgeData.RampDownProportion" [@"t - 1"] <= 0.00000000) THEN
            $ "FlamingGorgeData.RampDownProportion" [] := "RoundToNearestDay"( "DaysToDownramp"(  ) ) / "GetDaysInMonth"( @"t" );

      ELSE
            $ "FlamingGorgeData.RampDownProportion" [] := 0.00000000;

      END_IF_STATEMENT;

      END_IF_STATEMENT;

      END_IF_STATEMENT;

    END;

    RULE                 "Set Power Plant Capacity Proportion";
    DESCRIPTION          "In may 3 cases, (1) no ppc because ramping up is still taking place, (2) ppc for the rest of the month after ramp up or (3) ppc completely finishes";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "MonthIs"( { "May" , "June" , "July" } );
    BEGIN

      IF_STATEMENT ("MonthIs"( { "May" } )) THEN
            IF_STATEMENT ("RampUpDidFinishInMay"(  )) THEN
            IF_STATEMENT ("PPCReleaseDidFinishInMay"(  )) THEN
          DESCRIPTION          "Set PPC for the total available days";
      $ "FlamingGorgeData.PPCProportion" [] := $ "FlamingGorgeData.PPCDays" [] / "GetDaysInMonth"( @"t" );

          DESCRIPTION          "No more days left";
      $ "FlamingGorgeData.RemainingPPCDays" [@"t + 1"] := 0.00000000 "day";

      ELSE
          DESCRIPTION          "Set Power Plant capacity for remaining month proportion";
      $ "FlamingGorgeData.PPCProportion" [] := 1.00000000 - ( $ "FlamingGorgeData.RampUpProportion" [] + $ "FlamingGorgeData.PreviousMonthProportion" [] );

          DESCRIPTION          "Reduce ppc days";
      $ "FlamingGorgeData.RemainingPPCDays" [@"t + 1"] := $ "FlamingGorgeData.RemainingPPCDays" [@"t"] - ( 1.00000000 - ( $ "FlamingGorgeData.RampUpProportion" [] + $ "FlamingGorgeData.PreviousMonthProportion" [] ) ) * "GetDaysInMonth"( @"t" );

      END_IF_STATEMENT;

      ELSE
            $ "FlamingGorgeData.PPCProportion" [] := 0.00000000;

      END_IF_STATEMENT;

      END_IF_STATEMENT;

      IF_STATEMENT ("MonthIs"( { "June" } )) THEN
            IF_STATEMENT ("DaysLeftAtPPC"(  )) THEN
            IF_STATEMENT ("PPCReleaseCanFinishThisMonth"(  )) THEN
          DESCRIPTION          "1. Complete Power plant capacity release";
      $ "FlamingGorgeData.PPCProportion" [] := $ "FlamingGorgeData.RemainingPPCDays" [@"t"] / "GetDaysInMonth"( @"t" ) - $ "FlamingGorgeData.BypassProportion" [];

          DESCRIPTION          "Reduce ppc days";
      $ "FlamingGorgeData.RemainingPPCDays" [@"t + 1"] := 0.00000000 "day";

      ELSE
          DESCRIPTION          "2. Release at PPC for the whole month besides bypass period";
      $ "FlamingGorgeData.PPCProportion" [] := 1.00000000 - $ "FlamingGorgeData.BypassProportion" [];

          DESCRIPTION          "Reduce ppc days";
      $ "FlamingGorgeData.RemainingPPCDays" [@"t + 1"] := $ "FlamingGorgeData.RemainingPPCDays" [] - "GetDaysInMonth"( @"t" );

      END_IF_STATEMENT;

      ELSE
          DESCRIPTION          "3. PPC previously finished";
      $ "FlamingGorgeData.PPCProportion" [] := 0.00000000;

      END_IF_STATEMENT;

      END_IF_STATEMENT;

      IF_STATEMENT ("MonthIs"( { "July" } )) THEN
            IF_STATEMENT ("DaysLeftAtPPC"(  )) THEN
            IF_STATEMENT ("PPCReleaseCanFinishThisMonth"(  )) THEN
          DESCRIPTION          "1. Finish with time to spare";
      $ "FlamingGorgeData.PPCProportion" [] := $ "FlamingGorgeData.RemainingPPCDays" [@"t"] / "GetDaysInMonth"( @"t" );

      ELSE
            $ "FlamingGorgeData.PPCProportion" [] := 1.00000000 - "DaysToDownramp"(  ) / "GetDaysInMonth"( @"t" );

      END_IF_STATEMENT;

      ELSE
            $ "FlamingGorgeData.PPCProportion" [] := 0.00000000;

      END_IF_STATEMENT;

      END_IF_STATEMENT;

    END;

    RULE                 "Set Bypass Proportion";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "MonthIs"( { "June" } );
    BEGIN

      $ "FlamingGorgeData.BypassProportion" [] := "RoundToNearestDay"( "GetDaysAtBypass"(  ) ) / "GetDaysInMonth"( @"t" );

    END;

    RULE                 "Set Ramp Up Proportion";
    DESCRIPTION          "Ramping only begins in May (may end in June), on May 23.  Ramping may take more the 7 days from May 23 to the end of May.  In that case, June will get a small proportion from ramping.  ";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "MonthIs"( { "May" , "June" } );
    BEGIN

    DESCRIPTION          "Only ramp up in May";
      IF_STATEMENT ("MonthIs"( { "May" } )) THEN
            $ "FlamingGorgeData.RampUpProportion" [] := "RoundToNearestDay"( "Min"( "DaysToRampUp"( $ "FlamingGorge.Outflow" [@"t - 1"] ), $ "FlamingGorgeData.MayDaysAfterPeak" [] ) ) / "GetDaysInMonth"( @"t" );

      ELSE
            $ "FlamingGorgeData.RampUpProportion" [] := 0.00000000;

      END_IF_STATEMENT;

    END;

    RULE                 "Set Previous Proportion";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    BEGIN

      $ "FlamingGorgeData.PreviousMonthProportion" [] := IF ( "MonthIs"( { "May" } ) )
   THEN
      1.00000000 - $ "FlamingGorgeData.MayDaysAfterPeak" [] / "GetDaysInMonth"( @"t" )
   ELSE
      0.00000000
   ENDIF;

    END;

    RULE                 "Set Days at Power Plant Capacity";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    BEGIN

    DESCRIPTION          "Use the Yampa Hydrologic classification to determine days within range";
      IF_STATEMENT ("MonthIs"( { "May" } )) THEN
            $ "FlamingGorgeData.RemainingPPCDays" [] := "RoundToNearestDay"( "GetNumberOfDaysAtPPC"( $ "FlamingGorgeData.SpringHClass" [] ) );

            $ "FlamingGorgeData.PPCDays" [] := "RoundToNearestDay"( "GetNumberOfDaysAtPPC"( $ "FlamingGorgeData.SpringHClass" [] ) );

      END_IF_STATEMENT;

    END;

    RULE                 "Spring Flow Hydrologic Classification";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetMonthAsString"( @"t" ) IN { "" , "" , "March" , "April" , "May" , "June" , "July" };
    BEGIN

    DESCRIPTION          "Flaming Gorge";
      FOREACH (NUMERIC index IN { 0.00000000 , 1.00000000 , 2.00000000 , 3.00000000 , 4.00000000 }) DO
            IF_STATEMENT ($ "FlamingGorgeData.AprJulPercentExceedanceSpringFlow" [] <= $ "FlamingGorgeData.HydrologicClassPercentileLimits" [index, 1.00000000]) THEN
            IF_STATEMENT (IsNaN $ "FlamingGorgeData.SpringHClass" []) THEN
            $ "FlamingGorgeData.SpringHClass" [] := index;

      END_IF_STATEMENT;

      END_IF_STATEMENT;

      ENDFOREACH;

    DESCRIPTION          "Yampa";
      FOREACH (NUMERIC index IN { 0.00000000 , 1.00000000 , 2.00000000 , 3.00000000 , 4.00000000 }) DO
            IF_STATEMENT ($ "FlamingGorgeData.YampaAprJulPercentExceedance" [] <= $ "FlamingGorgeData.HydrologicClassPercentileLimits" [index, 1.00000000]) THEN
            IF_STATEMENT (IsNaN $ "FlamingGorgeData.YampaHClass" []) THEN
            $ "FlamingGorgeData.YampaHClass" [] := index;

      END_IF_STATEMENT;

      END_IF_STATEMENT;

      ENDFOREACH;

    END;

    RULE                 "Base Flow Hydrologic Classification";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    BEGIN

      FOREACH (NUMERIC index IN { 0.00000000 , 1.00000000 , 2.00000000 , 3.00000000 , 4.00000000 }) DO
            IF_STATEMENT ($ "FlamingGorgeData.AprJulPercentExceedanceBaseFlow" [] <= $ "FlamingGorgeData.HydrologicClassPercentileLimits" [index, 1.00000000]) THEN
            IF_STATEMENT (IsNaN $ "FlamingGorgeData.BaseFlowHClass" []) THEN
            $ "FlamingGorgeData.BaseFlowHClass" [] := index;

      END_IF_STATEMENT;

      END_IF_STATEMENT;

      ENDFOREACH;

    END;

    RULE                 "Calc Percent Exceedance";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    BEGIN

      $ "FlamingGorgeData.AprJulPercentExceedanceSpringFlow" [] := 1.00000000 - "PercentRank"( "GetSlotVals"( $ "FlamingGorgeData.AprJulVolAnnual", "GetDate"( "December 31, " CONCAT "GetYearAsString"( "NumberToDate"( $ "FlamingGorgeData.HydrologicClassificationStartYear" [] ) ) ), IF ( $ "HistoricData.UpdateHistoricRecord" [] == 1.00000000 )
   THEN
      "GetDate"( "December 31, " CONCAT ( GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetYear"( @"t" ) - 1.00000000, "." ) ) )
   ELSE
      "GetDate"( "December 31, " CONCAT "GetYearAsString"( "NumberToDate"( $ "FlamingGorgeData.HydrologicClassificationEndYear" [] ) ) )
   ENDIF ), $ "FlamingGorgeData.AprJulVolSpringFlow" [] );

      $ "FlamingGorgeData.AprJulPercentExceedanceBaseFlow" [] := 1.00000000 - "PercentRank"( "GetSlotVals"( $ "FlamingGorgeData.AprJulVolAnnual", "GetDate"( "December 31, " CONCAT "GetYearAsString"( "NumberToDate"( $ "FlamingGorgeData.HydrologicClassificationStartYear" [] ) ) ), IF ( $ "HistoricData.UpdateHistoricRecord" [] == 1.00000000 )
   THEN
      "GetDate"( "December 31, " CONCAT ( GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetYear"( @"t" ) - 1.00000000, "." ) ) )
   ELSE
      "GetDate"( "December 31, " CONCAT "GetYearAsString"( "NumberToDate"( $ "FlamingGorgeData.HydrologicClassificationEndYear" [] ) ) )
   ENDIF ), $ "FlamingGorgeData.AprJulVolBaseFlow" [] );

      $ "FlamingGorgeData.YampaAprJulPercentExceedance" [] := 1.00000000 - "PercentRank"( IF ( "GetYear"( "NumberToDate"( $ "FlamingGorgeData.YampaHydrologicClassificationStartYear" [] ) ) < "GetYear"( "RunStartDate"(  ) ) - 1.00000000 AND $ "HistoricData.UpdateHistoricRecord" [] == 1.00000000 )
   THEN
      IF ( "GetYear"( @"t" ) == "GetYear"( "RunStartDate"(  ) ) )
      THEN
         "GetSlotVals"( $ "FlamingGorgeData.YampaAprJulVolAnnual", "GetDate"( "December 31, " CONCAT "GetYearAsString"( "NumberToDate"( $ "FlamingGorgeData.YampaHydrologicClassificationStartYear" [] ) ) ), "GetDate"( "December 31, " CONCAT "GetYearAsString"( "NumberToDate"( $ "FlamingGorgeData.YampaHydrologicClassificationEndYear" [] ) ) ) )
      ELSE
         WITH LIST futureData = "GetSlotVals"( $ "FlamingGorgeData.YampaAprJulVolAnnual", "GetDate"( "December 31, " CONCAT "GetYearAsString"( "RunStartDate"(  ) ) ), "GetDate"( "December 31, " CONCAT ( GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetYear"( @"t" ) - 1.00000000, "." ) ) ) ) DO
            FOR ( NUMERIC i IN "GetNumbers"( 0.00000000, ( LENGTH futureData ) - 1.00000000, 1.00000000 ) ) WITH LIST result = "GetSlotVals"( $ "FlamingGorgeData.YampaAprJulVolAnnual", "GetDate"( "December 31, " CONCAT "GetYearAsString"( "NumberToDate"( $ "FlamingGorgeData.YampaHydrologicClassificationStartYear" [] ) ) ), "GetDate"( "December 31, " CONCAT "GetYearAsString"( "NumberToDate"( $ "FlamingGorgeData.YampaHydrologicClassificationEndYear" [] ) ) ) ) DO
               APPEND GET @INDEX i FROM futureData ONTO result
            ENDFOR
         ENDWITH
      ENDIF
   ELSE
      "GetSlotVals"( $ "FlamingGorgeData.YampaAprJulVolAnnual", "GetDate"( "December 31, " CONCAT "GetYearAsString"( "NumberToDate"( $ "FlamingGorgeData.YampaHydrologicClassificationStartYear" [] ) ) ), IF ( $ "HistoricData.UpdateHistoricRecord" [] == 1.00000000 )
      THEN
         "GetDate"( "December 31, " CONCAT ( GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetYear"( @"t" ) - 1.00000000, "." ) ) )
      ELSE
         "GetDate"( "December 31, " CONCAT "GetYearAsString"( "NumberToDate"( $ "FlamingGorgeData.YampaHydrologicClassificationEndYear" [] ) ) )
      ENDIF )
   ENDIF, $ "FlamingGorgeData.YampaAprJulVol" [] );

    END;

    RULE                 "Initilize Proportions";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    BEGIN

      $ "FlamingGorgeData.PreviousMonthProportion" [] := 0.00000000;

      $ "FlamingGorgeData.RampUpProportion" [] := 0.00000000;

      $ "FlamingGorgeData.BypassProportion" [] := 0.00000000;

      $ "FlamingGorgeData.PPCProportion" [] := 0.00000000;

      $ "FlamingGorgeData.RampDownProportion" [] := 0.00000000;

      $ "FlamingGorgeData.RemainingProportion" [] := 0.00000000;

      $ "FlamingGorgeData.ManualSpill" [] := 0.00000000 "acre-ft/month";

    END;

    RULE                 "Calc April July Volume Monthly";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    BEGIN

    DESCRIPTION          "For spring flow operations we are interested in the april - july <br>volume for the upcoming season, all the way into August we may be <br>refering to this number. This number is needed in march to determine<br>releases to meet the ULDE. ";
      $ "FlamingGorgeData.AprJulVolSpringFlow" [] := IF ( "MonthIs"( { "March" } ) )
   THEN
      "CalcUnregulatedInflowVolume"( "Greendale" COMMENTED_BY "Greendale is the NF gage corresponding to <br>above Flaming Gorge", @"24:00:00 April Max DayOfMonth, Current Year", @"24:00:00 July Max DayOfMonth, Current Year" )
   ELSE
      IF ( @"t" == "RunStartDate"(  ) )
      THEN
         "CalcUnregulatedInflowVolume"( "Greendale" COMMENTED_BY "Greendale is the NF gage corresponding to <br>above Flaming Gorge", @"24:00:00 April Max DayOfMonth, Current Year", @"24:00:00 July Max DayOfMonth, Current Year" )
      ELSE
         $ "FlamingGorgeData.AprJulVolSpringFlow" [@"t - 1"]
      ENDIF
   ENDIF;

    DESCRIPTION          "For base flow operations we are interested in the available observed<br>volume in the previous april - july season. Since base flow may actually <br>start in june calculate this number then.";
      $ "FlamingGorgeData.AprJulVolBaseFlow" [] := IF ( "MonthIs"( { "May" } ) )
   THEN
      "CalcUnregulatedInflowVolume"( "Greendale" COMMENTED_BY "Greendale is the NF gage corresponding to <br>above Flaming Gorge", @"24:00:00 April Max DayOfMonth, Current Year", @"24:00:00 July Max DayOfMonth, Current Year" )
   ELSE
      IF ( @"t" == "RunStartDate"(  ) )
      THEN
         "CalcUnregulatedInflowVolume"( "Greendale" COMMENTED_BY "Greendale is the NF gage corresponding to <br>above Flaming Gorge", @"24:00:00 April Max DayOfMonth, Current Year", @"24:00:00 July Max DayOfMonth, Current Year" )
      ELSE
         $ "FlamingGorgeData.AprJulVolBaseFlow" [@"t - 1"]
      ENDIF
   ENDIF;

      $ "FlamingGorgeData.YampaAprJulVol" [] := IF ( "MonthIs"( { "April" } ) )
   THEN
      "SumFlowsToVolume"( $ "YampaAtDeerlodge.Gage Inflow", @"t", @"t + 3" )
   ELSE
      IF ( @"t" == "RunStartDate"(  ) )
      THEN
         0.00000000 "acre-ft"
      ELSE
         $ "FlamingGorgeData.YampaAprJulVol" [@"t - 1"]
      ENDIF
   ENDIF;

    END;

    RULE                 "Update Historic Record";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "MonthIs"( { "August" } ) AND $ "HistoricData.UpdateHistoricRecord" [] == 1.00000000;
    BEGIN

      $ "FlamingGorgeData.YampaAprJulVolAnnual" [@"24:00:00 December Max DayOfMonth, Current Year"] := "SumFlowsToVolume"( $ "YampaAtDeerlodge.Gage Inflow", @"24:00:00 April Max DayOfMonth, Current Year", @"24:00:00 July Max DayOfMonth, Current Year" );

      $ "FlamingGorgeData.AprJulVolAnnual" [@"24:00:00 December Max DayOfMonth, Current Year"] := "CalcUnregulatedInflowVolume"( "Greendale" COMMENTED_BY "Greendale is the NF gage corresponding to <br>above Flaming Gorge", @"24:00:00 April Max DayOfMonth, Current Year", @"24:00:00 July Max DayOfMonth, Current Year" );

    END;

    RULE                 "Calculate April To July Volume Annual Slot";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == "RunStartDate"(  );
    BEGIN

    DESCRIPTION          "Flaming Gorge Unregulated Apr-Jul Inflow volume";
      FOREACH (DATETIME time IN "GetDates"( "NumberToDate"( $ "FlamingGorgeData.HydrologicClassificationStartYear" [] ), "NumberToDate"( $ "FlamingGorgeData.HydrologicClassificationEndYear" [] ), "1 years" )) DO
            $ "FlamingGorgeData.AprJulVolAnnual" ["GetDate"( "December 31, " CONCAT "GetYearAsString"( time ) )] := "SumFlowsToVolumeSkipNaN"( $ "HistoricData.FlamingGorgeUnregulatedInflow", "GetDate"( "April, " CONCAT "GetYearAsString"( time ) ), "GetDate"( "July, " CONCAT "GetYearAsString"( time ) ) );

      ENDFOREACH;

    DESCRIPTION          "Yampa Apr-Jul Inflow Vol";
      FOREACH (DATETIME time IN "GetDates"( "NumberToDate"( $ "FlamingGorgeData.YampaHydrologicClassificationStartYear" [] ), "NumberToDate"( $ "FlamingGorgeData.YampaHydrologicClassificationEndYear" [] ), "1 years" )) DO
            $ "FlamingGorgeData.YampaAprJulVolAnnual" ["GetDate"( "December 31, " CONCAT "GetYearAsString"( time ) )] := "SumFlowsToVolume"( $ "HistoricData.YampaAtDeerlodge", "GetDate"( "April, " CONCAT "GetYearAsString"( time ) ), "GetDate"( "July, " CONCAT "GetYearAsString"( time ) ) );

      ENDFOREACH;

    END;

  END;

  POLICY_GROUP   "Fontenelle";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  BEGIN

    RULE                 "ForecastFutureFGInflow-total average";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    BEGIN

      FOREACH (NUMERIC index IN "GetNumbers"( 1.00000000, IF ( "GetMonth"( @"24:00:00 April Max DayOfMonth, Next Year" ) - "GetMonth"( @"t + 1" ) < 0.00000000 )
   THEN
      12.00000000 - "Abs"( "GetMonth"( @"24:00:00 April Max DayOfMonth, Next Year" ) - "GetMonth"( @"t + 1" ) ) + 1.00000000
   ELSE
      "GetMonth"( @"24:00:00 April Max DayOfMonth, Next Year" ) - "GetMonth"( @"t + 1" ) + 1.00000000
   ENDIF, 1.00000000 )) DO
            $ "ForecastData.FlamingGorgeInflow" ["OffsetDate"( @"t", index, "1 MONTHS" )] := ( GET @INDEX index - 1.00000000 FROM GET @INDEX 1.00000000 FROM "ForecastFontenelleRelease"( @"t + 1", @"24:00:00 April Max DayOfMonth, Next Year" ) ) + WITH DATETIME currentDate = "OffsetDate"( @"t", index, "1 MONTHS" ) DO
      IF ( currentDate <= "RunEndDate"(  ) )
      THEN
         $ "GreenRAboveGreenRiverWY:GainsAboveGRWY.Local Inflow" ["OffsetDate"( @"t", index, "1 MONTHS" )] + $ "GreenRAboveFlamingGorge:GainsAboveGreendale.Local Inflow" ["OffsetDate"( @"t", index, "1 MONTHS" )] - "SumObjectsAggregatedOverTime"( "DemandsBetweenFontenelleAndFlamingGorge", "Total Depletion Requested", "SUM", "ALL", FALSE, "OffsetDate"( @"t", index, "1 MONTHS" ), "OffsetDate"( @"t", index, "1 MONTHS" ) )
      ELSE
         ( "MonthlyAverageFlowInModel"( $ "GreenRAboveGreenRiverWY:GainsAboveGRWY.Local Inflow", "GetMonthAsString"( currentDate ), "GetYear"( "RunStartDate"(  ) ), "GetYear"( "RunEndDate"(  ) ) ) + "MonthlyAverageFlowInModel"( $ "GreenRAboveFlamingGorge:GainsAboveGreendale.Local Inflow", "GetMonthAsString"( currentDate ), "GetYear"( "RunStartDate"(  ) ), "GetYear"( "RunEndDate"(  ) ) ) - "SumObjectsAggregatedOverTime"( "DemandsBetweenFontenelleAndFlamingGorge", "Total Depletion Requested", "SUM", "ALL", FALSE, "GetDate"( "GetMonthAsString"( currentDate ) CONCAT ", " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetYear"( "RunEndDate"(  ) ), "." ) ), "GetDate"( "GetMonthAsString"( currentDate ) CONCAT ", " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetYear"( "RunEndDate"(  ) ), "." ) ) ) COMMENTED_BY "And use the total depletion requested of the last year of the model run for the given month" ) COMMENTED_BY "If we are trying to determine the forecasted FG Inflow after the model end date,<br>then use the average monthly natural flow for the forecasted natural flow"
      ENDIF
   ENDWITH;

      ENDFOREACH;

    END;

    RULE                 "ForecastFutureFGInflow-5 year average";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT TRUE;
    BEGIN

      FOREACH (NUMERIC index IN "GetNumbers"( 1.00000000, IF ( "GetMonth"( @"24:00:00 April Max DayOfMonth, Next Year" ) - "GetMonth"( @"t + 1" ) < 0.00000000 )
   THEN
      12.00000000 - "Abs"( "GetMonth"( @"24:00:00 April Max DayOfMonth, Next Year" ) - "GetMonth"( @"t + 1" ) ) + 1.00000000
   ELSE
      "GetMonth"( @"24:00:00 April Max DayOfMonth, Next Year" ) - "GetMonth"( @"t + 1" ) + 1.00000000
   ENDIF, 1.00000000 )) DO
            $ "ForecastData.FlamingGorgeInflow" ["OffsetDate"( @"t", index, "1 MONTHS" )] := ( GET @INDEX index - 1.00000000 FROM GET @INDEX 1.00000000 FROM "ForecastFontenelleRelease"( @"t + 1", @"24:00:00 April Max DayOfMonth, Next Year" ) ) + WITH DATETIME currentDate = "OffsetDate"( @"t", index, "1 MONTHS" ) DO
      IF ( currentDate <= "RunEndDate"(  ) )
      THEN
         $ "GreenRAboveGreenRiverWY:GainsAboveGRWY.Local Inflow" ["OffsetDate"( @"t", index, "1 MONTHS" )] + $ "GreenRAboveFlamingGorge:GainsAboveGreendale.Local Inflow" ["OffsetDate"( @"t", index, "1 MONTHS" )] - "SumObjectsAggregatedOverTime"( "DemandsBetweenFontenelleAndFlamingGorge", "Total Depletion Requested", "SUM", "ALL", FALSE, "OffsetDate"( @"t", index, "1 MONTHS" ), "OffsetDate"( @"t", index, "1 MONTHS" ) )
      ELSE
         ( "MonthlyAverageFlowInModel"( $ "GreenRAboveGreenRiverWY:GainsAboveGRWY.Local Inflow", "GetMonthAsString"( currentDate ), "GetYear"( "RunEndDate"(  ) ) - 4.00000000, "GetYear"( "RunEndDate"(  ) ) ) + "MonthlyAverageFlowInModel"( $ "GreenRAboveFlamingGorge:GainsAboveGreendale.Local Inflow", "GetMonthAsString"( currentDate ), "GetYear"( "RunEndDate"(  ) ) - 4.00000000, "GetYear"( "RunEndDate"(  ) ) ) - "SumObjectsAggregatedOverTime"( "DemandsBetweenFontenelleAndFlamingGorge", "Total Depletion Requested", "SUM", "ALL", FALSE, "GetDate"( "GetMonthAsString"( currentDate ) CONCAT ", " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetYear"( "RunEndDate"(  ) ), "." ) ), "GetDate"( "GetMonthAsString"( currentDate ) CONCAT ", " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetYear"( "RunEndDate"(  ) ), "." ) ) ) COMMENTED_BY "And use the total depletion requested of the last year of the model run for the given month" ) COMMENTED_BY "If we are trying to determine the forecasted FG Inflow after the model end date,<br>then use the average monthly natural flow for the forecasted natural flow"
      ENDIF
   ENDWITH;

      ENDFOREACH;

    END;

    RULE                 "ForecastFutureFGInflow-last year";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT TRUE;
    BEGIN

      FOREACH (NUMERIC index IN "GetNumbers"( 1.00000000, IF ( "GetMonth"( @"24:00:00 April Max DayOfMonth, Next Year" ) - "GetMonth"( @"t + 1" ) < 0.00000000 )
   THEN
      12.00000000 - "Abs"( "GetMonth"( @"24:00:00 April Max DayOfMonth, Next Year" ) - "GetMonth"( @"t + 1" ) ) + 1.00000000
   ELSE
      "GetMonth"( @"24:00:00 April Max DayOfMonth, Next Year" ) - "GetMonth"( @"t + 1" ) + 1.00000000
   ENDIF, 1.00000000 )) DO
            $ "ForecastData.FlamingGorgeInflow" ["OffsetDate"( @"t", index, "1 MONTHS" )] := ( GET @INDEX index - 1.00000000 FROM GET @INDEX 1.00000000 FROM "ForecastFontenelleRelease"( @"t + 1", @"24:00:00 April Max DayOfMonth, Next Year" ) ) + WITH DATETIME currentDate = "OffsetDate"( @"t", index, "1 MONTHS" ) DO
      IF ( currentDate <= "RunEndDate"(  ) )
      THEN
         $ "GreenRAboveGreenRiverWY:GainsAboveGRWY.Local Inflow" ["OffsetDate"( @"t", index, "1 MONTHS" )] + $ "GreenRAboveFlamingGorge:GainsAboveGreendale.Local Inflow" ["OffsetDate"( @"t", index, "1 MONTHS" )] - "SumObjectsAggregatedOverTime"( "DemandsBetweenFontenelleAndFlamingGorge", "Total Depletion Requested", "SUM", "ALL", FALSE, "OffsetDate"( @"t", index, "1 MONTHS" ), "OffsetDate"( @"t", index, "1 MONTHS" ) )
      ELSE
         ( "MonthlyAverageFlowInModel"( $ "GreenRAboveGreenRiverWY:GainsAboveGRWY.Local Inflow", "GetMonthAsString"( currentDate ), "GetYear"( "RunEndDate"(  ) ), "GetYear"( "RunEndDate"(  ) ) ) + "MonthlyAverageFlowInModel"( $ "GreenRAboveFlamingGorge:GainsAboveGreendale.Local Inflow", "GetMonthAsString"( currentDate ), "GetYear"( "RunEndDate"(  ) ), "GetYear"( "RunEndDate"(  ) ) ) - "SumObjectsAggregatedOverTime"( "DemandsBetweenFontenelleAndFlamingGorge", "Total Depletion Requested", "SUM", "ALL", FALSE, "GetDate"( "GetMonthAsString"( currentDate ) CONCAT ", " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetYear"( "RunEndDate"(  ) ), "." ) ), "GetDate"( "GetMonthAsString"( currentDate ) CONCAT ", " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetYear"( "RunEndDate"(  ) ), "." ) ) ) COMMENTED_BY "And use the total depletion requested of the last year of the model run for the given month" ) COMMENTED_BY "If we are trying to determine the forecasted FG Inflow after the model end date,<br>then use the average monthly natural flow for the forecasted natural flow"
      ENDIF
   ENDWITH;

      ENDFOREACH;

    END;

    RULE                 "Min Flow";
    DESCRIPTION          "This rule ensurs that the minimum instream flow requirements are met. If a lower priority rule sets the flow lower than the min flow then this rule resets the flow. ";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( "HasAnyRuleFired"( { "Safe Channel Capacity" , "Set September-November Baseflow" , "Set December-March Baseflow" , "Set April or August Outflow" , "Set Baseflow in off month" , "Set June Outflow" , "Set July Outflow" } ) AND NOT "HasRuleFiredSuccessfully"( "Min Flow" ) ) COMMENTED_BY "This is necessary for 1,2,3 rule order to prevent trumping of lower priority rules. <br>Not necessary in 3,2,1 order but does not hurt anything. ";
    BEGIN

      IF_STATEMENT ($ "Fontenelle.Outflow" [] < $ "FontenelleData.MinFlow" []) THEN
            $ "Fontenelle.Outflow" [] := "Min"( $ "FontenelleData.MinFlow" [], "AvailableWaterInStorage"( % "Fontenelle" ) );

      END_IF_STATEMENT;

    END;

    RULE                 "Max Elevation";
    DESCRIPTION          "This rule prevents overtopping. If a previous rule sets the outflow such that the elevation would overtop the dam, this rule will set the outflow to prevent this. The ";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "HasAnyRuleFired"( { "Safe Channel Capacity" , "Set September-November Baseflow" , "Set December-March Baseflow" , "Set April or August Outflow" , "Set Baseflow in off month" , "Set June Outflow" , "Set July Outflow" } ) COMMENTED_BY "This is necessary for 1,2,3 rule order to prevent trumping of lower priority rules. <br>Not necessary in 3,2,1 order but does not hurt anything. ";
    BEGIN

      IF_STATEMENT ($ "Fontenelle.Pool Elevation" [] > $ "FontenelleData.MaxElevation" []) THEN
          DESCRIPTION          "If the Pool elevation goes higher than the max elevation then release whatever necessary to not overtop";
      $ "Fontenelle.Outflow" [] := $ "Fontenelle.Outflow" [] + "VolumeToFlow"( "ElevationToStorage"( % "Fontenelle", $ "Fontenelle.Pool Elevation" [] ) - "ElevationToStorage"( % "Fontenelle", $ "FontenelleData.MaxElevation" [] ), @"t" );

      END_IF_STATEMENT;

    END;

    RULE                 "Min Elevation";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    BEGIN

      IF_STATEMENT ($ "Fontenelle.Pool Elevation" [] < $ "FontenelleData.MinElevation" []) THEN
            $ "Fontenelle.Outflow" [] := "SolveOutflow"( % "Fontenelle", $ "Fontenelle.Inflow" [], "ElevationToStorage"( % "Fontenelle", $ "FontenelleData.MinElevation" [] ), $ "Fontenelle.Storage" [@"t - 1"], @"t" );

      END_IF_STATEMENT;

    END;

    RULE                 "Safe Channel Capacity";
    DESCRIPTION          "Prevents outflow from exceeding safe channel capacity unless there is a chance of overtopping, in which case, the &quot;Max Elevation&quot; rule will take precedence. ";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "HasAnyRuleFired"( { "Safe Channel Capacity" , "Set September-November Baseflow" , "Set December-March Baseflow" , "Set April or August Outflow" , "Set Baseflow in off month" , "Set June Outflow" , "Set July Outflow" } );
    BEGIN

      IF_STATEMENT ($ "Fontenelle.Outflow" [] > $ "FontenelleData.SafeChannelCapacity" []) THEN
            $ "Fontenelle.Outflow" [] := $ "FontenelleData.SafeChannelCapacity" [];

      END_IF_STATEMENT;

    END;

    RULE                 "Set September-November Baseflow";
    DESCRIPTION          "Compute the steady flow over September to March necsessary to meet Apr 1 target. <br>Change in storage plus forecasted volume divided by 3 months.  The next two months <br>will look back at this value.";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetMonthAsString"( @"t" ) IN { "September" };
    BEGIN

    INACTIVE      PRINT "September";

    DESCRIPTION          "Compute the steady flow over September to March necsessary to meet Apr 1 target. <br>Change in storage plus forecasted volume divided by 3 months.  The next two months <br>will look back at this value.";
      $ "Fontenelle.Outflow" [] := ( "ElevationToStorage"( % "Fontenelle", $ "Fontenelle.Pool Elevation" [@"t"] ) - "ElevationToStorage"( % "Fontenelle", $ "FontenelleData.April1Target" [] ) + "SumFlowsToVolume"( $ "Fontenelle.Inflow", @"t", @"t + 6" ) ) / 7.00000000 "month";

    END;

    RULE                 "Set December-March Baseflow";
    DESCRIPTION          "This rule is the second of two that set the steady baseflow at Fontenelle.  This rule looks ahead at the forecasted volumes and determines what the max steady flow for the months of September-March can be. ";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetMonthAsString"( @"t" ) IN { "December" };
    BEGIN

    DESCRIPTION          "Compute the steady flow over December to March necsessary to meet Apr 1 target. <br>Change in storage plus forecasted volume divided by 4 months. <br>The next 3 months will look back at this value.";
      $ "Fontenelle.Outflow" [] := ( "ElevationToStorage"( % "Fontenelle", $ "Fontenelle.Pool Elevation" [@"t"] ) - "ElevationToStorage"( % "Fontenelle", $ "FontenelleData.April1Target" [] ) + "SumFlowsToVolume"( $ "Fontenelle.Inflow", @"t", @"t + 3" ) ) / 4.00000000 "month";

    END;

    RULE                 "Set August Outflow";
    DESCRIPTION          "Sets the April and August release to the maximum possible, this also sets May since may gets set to the same as April.";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetMonthAsString"( @"t" ) IN { "August" , "" } AND NOT "HasRuleFiredSuccessfully"( "Set August Outflow" );
    BEGIN

    DESCRIPTION          "Only set value of Outflow if set to avoid error messages";
      IF_STATEMENT (NaNToZero ( $ "Fontenelle.Outflow" [] ) != 0.00000000 "cfs") THEN
          DESCRIPTION          "Set April or August Outflow to power plant capacity";
      $ "Fontenelle.Outflow" [] := "GetMaxReleaseGivenInflow"( % "Fontenelle", $ "Fontenelle.Inflow" [], @"t" );

      END_IF_STATEMENT;

    END;

    RULE                 "Set April Outflow";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetMonthAsString"( @"t" ) IN { "" , "April" } AND NOT "HasRuleFiredSuccessfully"( "Set April Outflow" );
    BEGIN

      IF_STATEMENT (NaNToZero ( $ "Fontenelle.Outflow" [] ) != 0.00000000 "cfs") THEN
            $ "Fontenelle.Outflow" [] := "Min"( ( ( "ElevationToStorage"( % "Fontenelle", $ "Fontenelle.Pool Elevation" [@"t"] ) - "ElevationToStorage"( % "Fontenelle", $ "FontenelleData.July1Target" [] ) + "SumFlowsToVolume"( $ "Fontenelle.Inflow", @"t", @"t + 2" ) ) / 3.00000000 "month" ) COMMENTED_BY "Steady release over April, May and June to meet August1 Target", "GetMaxReleaseGivenInflow"( % "Fontenelle", $ "Fontenelle.Inflow" [], @"t" ) COMMENTED_BY "Power Plant Capacity" );

      END_IF_STATEMENT;

    END;

    RULE                 "Set May Outflow Old";
    DESCRIPTION          "First check if the August1 target will approamately be met, if not, continue base flow operations.   Otherwise ppc";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT "GetMonthAsString"( @"t" ) IN { "May" };
    BEGIN

      IF_STATEMENT (NaNToZero ( $ "Fontenelle.Outflow" [] ) != 0.00000000 "cfs") THEN
            IF_STATEMENT ("StorageToElevation"( % "Fontenelle", ( "ElevationToStorage"( % "Fontenelle", $ "Fontenelle.Pool Elevation" [@"t"] ) - "FlowToVolume"( "GetMaxReleaseGivenInflow"( % "Fontenelle", $ "Fontenelle.Inflow" [], @"t" ) * 2.00000000, @"t" ) + "SumFlowsToVolume"( $ "Fontenelle.Inflow", @"t", @"t + 1" ) ) ) COMMENTED_BY "If approx August 1 elevation after 2 months of power plant capacity does not <br>meet the August 1 target, continue base flow operations" < $ "FontenelleData.August1Target" []) THEN
            $ "Fontenelle.Outflow" [] := $ "Fontenelle.Outflow" [@"t - 1"];

      ELSE
          DESCRIPTION          "Set to power plant capacity";
      $ "Fontenelle.Outflow" [] := "GetMaxReleaseGivenInflow"( % "Fontenelle", $ "Fontenelle.Inflow" [], @"t" );

      END_IF_STATEMENT;

      END_IF_STATEMENT;

    END;

    RULE                 "Set Baseflow in off month";
    DESCRIPTION          "Handles the case when the model is started in October, November, January, February, March, or May. In these months the baseflow needs to be set to whatever the previous month's value was. ";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetMonthAsString"( @"t" ) IN { "October" , "November" , "January" , "February" , "March" , "May" } AND NOT "HasRuleFiredSuccessfully"( "Set Baseflow in off month" );
    BEGIN

      $ "Fontenelle.Outflow" [] := "Min"( $ "Fontenelle.Outflow" [@"t - 1"], "AvailableWaterInStorage"( % "Fontenelle" ) );

    END;

    RULE                 "Set June Outflow";
    DESCRIPTION          "This rule sets the June outflow such that the july 1 target elevation is met.  Alternate cases are when SolveOutflow returns a value greater the the max possible release or less than power plant capacity.  Min(MaxRelease, Max(Release to meet target, power plant capactiy)).";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetMonthAsString"( @"t" ) IN { "June" };
    BEGIN

      IF_STATEMENT ($ "Fontenelle.Pool Elevation" [] > $ "FontenelleData.July1Target" []) THEN
            $ "Fontenelle.Outflow" [] := "FontenelleTargetFlow"( $ "FontenelleData.August1Target" [] );

      ELSE
            $ "Fontenelle.Outflow" [] := "FontenelleTargetFlow"( $ "FontenelleData.July1Target" [] );

      END_IF_STATEMENT;

    END;

    RULE                 "Set July Outflow";
    DESCRIPTION          "Solve for the outflow which will cause the pool elevation to reach the end of timestep target. Do not let outflow go below power plant capacity or above the max possible release.";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetMonthAsString"( @"t" ) IN { "July" };
    BEGIN

      $ "Fontenelle.Outflow" [] := "FontenelleTargetFlow"( $ "FontenelleData.August1Target" [] );

    END;

    RULE                 "Set Unset Outflow";
    DESCRIPTION          "Sets the outflow for spillCalc and power methods, registering dependencies so that higher priority rules can set values. ";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    BEGIN

      $ "Fontenelle.Outflow" [] := $ "Fontenelle.Inflow" [];

    END;

  END;

  POLICY_GROUP   "Starvation Rules";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  BEGIN

    RULE                 "Starvation Rule Curve";
    DESCRIPTION          "This rule fires monthly and sets the storage for Starvation. Starvation is a virtual reservoir and represents a composite of 8 small reservoirs that are part of the Central Utah Project, located primarily on the Duschene. It computes the storage based on the whichever release demand is greater - the release to meet downstream demands or the release to meet the storage rule curve.";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT IsNaN $ "Starvation.Outflow" [];
    BEGIN

      $ "Starvation.Outflow" [] := "SolveOutflow"( % "Starvation", $ "Starvation.Inflow" [], "ComputeStorageAtGivenOutflow"( % "Starvation", "Max"( "ComputeOutflowAtRuleCurveStorage"( % "Starvation" ), "ComputeDemandsBelow"( % "Starvation" ) ) ), $ "Starvation.Storage" [@"t - 1"], @"t" );

    END;

  END;

  POLICY_GROUP   "Normal and Other Rules";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  BEGIN

    RULE                 "Set PVID Fallow Amount";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January 31, Current Year";
    BEGIN

      $ "California ICS.PVID Fallow Amount" [@"24:00:00 December 31, Current Year"] := IF ( @"t" == @"24:00:00 January 31, 2010" )
   THEN
      150000.00000000 "acre-ft"
   ELSE
      IF ( @"t" == @"24:00:00 January 31, 2011" )
      THEN
         110000.00000000 "acre-ft"
      ELSE
         IF ( @"t" >= @"24:00:00 January 31, 2012" AND @"t" <= @"24:00:00 January 31, 2039" )
         THEN
            IF ( "IsEven"( "GetYear"( @"t" ), 1.00000000 ) )
            THEN
               IF ( $ "Mead.Pool Elevation" [@"24:00:00 December 31, Previous Year"] > $ "California ICS.PVIDFallowing" [0.00000000, 0.00000000] )
               THEN
                  $ "California ICS.PVIDFallowing" [0.00000000, 1.00000000]
               ELSE
                  IF ( $ "Mead.Pool Elevation" [@"24:00:00 December 31, Previous Year"] >= $ "California ICS.PVIDFallowing" [1.00000000, 0.00000000] AND $ "Mead.Pool Elevation" [@"24:00:00 December 31, Previous Year"] <= $ "California ICS.PVIDFallowing" [0.00000000, 0.00000000] )
                  THEN
                     $ "California ICS.PVIDFallowing" [1.00000000, 1.00000000]
                  ELSE
                     IF ( @"t" < @"24:00:00 January 31, 2020" )
                     THEN
                        $ "California ICS.PVIDFallowing" [2.00000000, 1.00000000]
                     ELSE
                        IF ( "SumSlot"( $ "California ICS.PVID Fallow Amount", @"24:00:00 December 31, Previous Year - 7 Year", @"24:00:00 December 31, Previous Year" ) - 8.00000000 * $ "California ICS.PVIDFallowing" [2.00000000, 1.00000000] <= 0.00000000 "acre-ft" AND "SumSlot"( $ "California ICS.PVID Fallow Amount", @"24:00:00 December 31, Previous Year - 7 Year", @"24:00:00 December 31, Previous Year" ) - 8.00000000 * $ "California ICS.PVIDFallowing" [2.00000000, 1.00000000] >= - 1.00000000 "acre-ft" )
                        THEN
                           $ "California ICS.PVIDFallowing" [3.00000000, 1.00000000]
                        ELSE
                           $ "California ICS.PVIDFallowing" [2.00000000, 1.00000000]
                        ENDIF COMMENTED_BY "check to see if PVID has been fallowing 110 kaf for 8 consecutive years by substracting the last 8yr fallowing amount from 880 kaf (110 kaf * 8). due to significant digits, the SumSlot function results in slightly less than 880 kaf, which is why the <=0 and >=-1 was necessary"
                     ENDIF COMMENTED_BY "Mead is less than 1105 fallow 110 kaf unless 8 consecutive years of 110 kaf, then fallow 100 kaf"
                  ENDIF COMMENTED_BY "if Mead is between 1105 and 1140 fallow 50 kaf"
               ENDIF COMMENTED_BY "if Mead is greater than 1140 fallow 26 kaf<br>"
            ELSE
               $ "California ICS.PVID Fallow Amount" [@"24:00:00 December 31, Previous Year"] COMMENTED_BY "it's an odd year so fallow same amount as last year"
            ENDIF COMMENTED_BY "if current year is even (fallowing amount is set for 2-yr period beginning 2012), determine fallowing amount based on Mead elevation"
         ELSE
            0.00000000 "acre-ft" COMMENTED_BY "it's after 2039 so the fallowing program has ended"
         ENDIF COMMENTED_BY "last year of fallowing program is 2039<br>"
      ENDIF
   ENDIF;

    END;

    RULE                 "Set MWD Normal Schedule";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January 31, Current Year";
    BEGIN

      FOREACH (DATETIME date IN @"t" TO @"t + 11") DO
            $ "MWDDiversion:MWDDiversion.Diversion Requested" [date] := "Max"( IF ( "NotShortageYear"(  ) )
   THEN
      $ "MWDSchedule.Input Diversion Normal Schedule" [date]
   ELSE
      $ "MWDSchedule.Input Diversion Shortage Schedule" [date]
   ENDIF + "PVID Fallow Amount"( date, "MWD" ), 0.00000000 "acre-ft/month" );

            $ "MWDSchedule.Diversion Schedule" [date] := "Max"( IF ( "NotShortageYear"(  ) )
   THEN
      $ "MWDSchedule.Input Diversion Normal Schedule" [date]
   ELSE
      $ "MWDSchedule.Input Diversion Shortage Schedule" [date]
   ENDIF + "PVID Fallow Amount"( date, "MWD" ), 0.00000000 "acre-ft/month" );

            $ "MWDDiversion:MWDDiversion.Depletion Requested" [date] := "Max"( IF ( "NotShortageYear"(  ) )
   THEN
      $ "MWDSchedule.Input Depletion Normal Schedule" [date]
   ELSE
      $ "MWDSchedule.Input Depletion Shortage Schedule" [date]
   ENDIF + "PVID Fallow Amount"( date, "MWD" ), 0.00000000 "acre-ft/month" );

            $ "MWDSchedule.Depletion Schedule" [date] := "Max"( IF ( "NotShortageYear"(  ) )
   THEN
      $ "MWDSchedule.Input Depletion Normal Schedule" [date]
   ELSE
      $ "MWDSchedule.Input Depletion Shortage Schedule" [date]
   ENDIF + "PVID Fallow Amount"( date, "MWD" ), 0.00000000 "acre-ft/month" );

            $ "MWDSchedule.Input Diversion Schedule" [date] := "Max"( IF ( "NotShortageYear"(  ) )
   THEN
      $ "MWDSchedule.Input Diversion Normal Schedule" [date]
   ELSE
      $ "MWDSchedule.Input Diversion Shortage Schedule" [date]
   ENDIF, 0.00000000 "acre-ft/month" );

            $ "MWDSchedule.Input Depletion Schedule" [date] := "Max"( IF ( "NotShortageYear"(  ) )
   THEN
      $ "MWDSchedule.Input Depletion Normal Schedule" [date]
   ELSE
      $ "MWDSchedule.Input Depletion Shortage Schedule" [date]
   ENDIF, 0.00000000 "acre-ft/month" );

            $ "MWDSchedule.SurplusScheduleFlag" [date] := 0.00000000;

            $ "MWDSchedule.ShortageScheduleFlag" [date] := 0.00000000;

            $ "MWDSchedule.UsingShortageScheduleFlag" [date] := IF ( "NotShortageYear"(  ) )
   THEN
      0.00000000
   ELSE
      1.00000000
   ENDIF;

      ENDFOREACH;

    END;

    RULE                 "Set PVID Normal Schedule";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January Max DayOfMonth, Current Year";
    BEGIN

      FOREACH (DATETIME date IN @"t" TO @"t + 11") DO
            FOREACH (STRING user IN { "PVIDDiversionAG" , "PVIDDiversionNRG" }) DO
            "GetObject"( "PVIDDiversion:" CONCAT user ) & "Depletion Requested" [date] := % "PVIDSchedule" & ( user CONCAT "_Depletion Requested" ) [date];

            "GetObject"( "PVIDDiversion:" CONCAT user ) & "Diversion Requested" [date] := % "PVIDSchedule" & ( user CONCAT "_Diversion Requested" ) [date];

      ENDFOREACH;

            $ "PVIDSchedule.Diversion Schedule" [date] := $ "PVIDSchedule.Total Diversion Schedule" [date];

            $ "PVIDSchedule.Depletion Schedule" [date] := $ "PVIDSchedule.Total Depletion Schedule" [date];

      ENDFOREACH;

    END;

    RULE                 "Set CAP Normal Schedule";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January Max DayOfMonth, Current Year";
    BEGIN

      FOREACH (DATETIME date IN @"t" TO @"t + 11") DO
            FOREACH (STRING user IN "ListLBNormalWaterUsersByProvider"( "CAP" )) DO
            "GetObject"( "CAPDiversion:" CONCAT user ) & "Depletion Requested" [date] := % "CAPSchedule" & ( user CONCAT "_Depletion Requested" ) [date];

            "GetObject"( "CAPDiversion:" CONCAT user ) & "Diversion Requested" [date] := % "CAPSchedule" & ( user CONCAT "_Diversion Requested" ) [date];

      ENDFOREACH;

            $ "CAPSchedule.SurplusScheduleFlag" [date] := 0.00000000;

            $ "CAPSchedule.ShortageScheduleFlag" [date] := 0.00000000;

      ENDFOREACH;

    END;

    RULE                 "Set PVID Fallow Amount to 0";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    BEGIN

    DESCRIPTION          "Fallow amount is embedded in MWD and PVID schedules so no logic is<br>necessary to represent fallowing.";
      $ "California ICS.PVID Fallow Amount" [@"24:00:00 December 31, Current Year"] := 0.00000000 "acre-ft";

    END;

    RULE                 "Set Mexico Normal Schedule";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January Max DayOfMonth, Current Year";
    BEGIN

      FOREACH (DATETIME date IN @"t" TO @"t + 11") DO
            $ "MexicoDiversion:MexicoDiversion.Diversion Requested" [date] := $ "MexicoSchedule.Diversion Schedule" [date];

            $ "MexicoDiversion:MexicoDiversion.Depletion Requested" [date] := $ "MexicoSchedule.Depletion Schedule" [date];

            $ "MexicoSchedule.SurplusScheduleFlag" [date] := 0.00000000;

            $ "MexicoSchedule.ShortageScheduleFlag" [date] := 0.00000000;

      ENDFOREACH;

    END;

    RULE                 "Set Mexico Over Delivery Schedule Drop 2";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January 31, Current Year" AND @"t" >= @"24:00:00 January 31, 2010";
    BEGIN

      FOREACH (DATETIME date IN @"t" TO @"t + 11") DO
            $ "OverDeliveryToMexico:OverDeliveryToMexico.Diversion Requested" [date] := "VolumeToFlow"( IF ( @"t" == "RunStartDate"(  ) )
   THEN
      $ "MexicoSchedule.OverDeliveryFirstYear" []
   ELSE
      $ "MexicoSchedule.OverDelivery" []
   ENDIF - $ "MexicoSchedule.Drop2Recovery" [], date ) * $ "Surplus.MonthlyPercents" ["GetMonthAsString"( date ), "Mexico"];

            $ "OverDeliveryToMexico:OverDeliveryToMexico.Depletion Requested" [date] := "VolumeToFlow"( IF ( @"t" == "RunStartDate"(  ) )
   THEN
      $ "MexicoSchedule.OverDeliveryFirstYear" []
   ELSE
      $ "MexicoSchedule.OverDelivery" []
   ENDIF - $ "MexicoSchedule.Drop2Recovery" [], date ) * $ "Surplus.MonthlyPercents" ["GetMonthAsString"( date ), "Mexico"];

      ENDFOREACH;

    END;

    RULE                 "Set Coachella Normal Schedule";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January Max DayOfMonth, Current Year";
    BEGIN

      FOREACH (DATETIME date IN @"t" TO @"t + 11") DO
            FOREACH (STRING user IN { "CoachellaDiversionAG" , "CoachellaDiversionMandI" , "CoachellaDiversionFWR" }) DO
            "GetObject"( "CoachellaDiversion:" CONCAT user ) & "Depletion Requested" [date] := % "CoachellaSchedule" & ( user CONCAT "_Depletion Requested" ) [date];

            "GetObject"( "CoachellaDiversion:" CONCAT user ) & "Diversion Requested" [date] := % "CoachellaSchedule" & ( user CONCAT "_Diversion Requested" ) [date];

      ENDFOREACH;

            $ "CoachellaSchedule.ShortageScheduleFlag" [date] := 0.00000000;

            $ "CoachellaSchedule.SurplusScheduleFlag" [date] := 0.00000000;

      ENDFOREACH;

    END;

    RULE                 "Set IID Normal Schedule";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January Max DayOfMonth, Current Year";
    BEGIN

      FOREACH (DATETIME date IN @"t" TO @"t + 11") DO
            FOREACH (STRING user IN { "IIDDiversionAG" , "IIDDiversionMandI" , "IIDDiversionNRG" , "IIDDiversionFWR" }) DO
            "GetObject"( "IIDDiversion:" CONCAT user ) & "Depletion Requested" [date] := % "IIDSchedule" & ( user CONCAT "_Depletion Requested" ) [date];

            "GetObject"( "IIDDiversion:" CONCAT user ) & "Diversion Requested" [date] := % "IIDSchedule" & ( user CONCAT "_Diversion Requested" ) [date];

      ENDFOREACH;

            $ "IIDSchedule.SurplusScheduleFlag" [date] := 0.00000000;

            $ "IIDSchedule.ShortageScheduleFlag" [date] := 0.00000000;

      ENDFOREACH;

    END;

    RULE                 "Set Arizona Priority 2, 3 and 4 Normal Schedules";
    DESCRIPTION          "This rule fires once a year and sets the Arizona 2nd, 3rd and 4th (excluding CAP) priority users to their Normal schedules. The Normal schedule for these users may be adjusted during a Shortage. View subbasins Other Arizona Priority 4 Users, Arizona Priority 2 and 3 Users to see specifically which users are included. ";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January 31, Current Year";
    BEGIN

      FOREACH (DATETIME date IN @"t" TO @"24:00:00 December 31, Current Year") DO
            FOREACH (OBJECT diversion IN "OtherArizonaPriority4UsersWaterUser"(  )) DO
            diversion CONCAT ".Depletion Requested" [date] := "ArizonaPriority4Schedules.Depletion_" CONCAT "GetSlotNameForScheduleWaterUser"( STRINGIFY diversion ) [date];

            diversion CONCAT ".Diversion Requested" [date] := "ArizonaPriority4Schedules.Diversion_" CONCAT "GetSlotNameForScheduleWaterUser"( STRINGIFY diversion ) [date];

      ENDFOREACH;

            FOREACH (OBJECT diversion IN "ArizonaPriority2and3UsersWaterUser"(  )) DO
            diversion CONCAT ".Depletion Requested" [date] := "ArizonaPriority2and3Schedules.Depletion_" CONCAT "GetSlotNameForScheduleWaterUser"( STRINGIFY diversion ) [date];

            diversion CONCAT ".Diversion Requested" [date] := "ArizonaPriority2and3Schedules.Diversion_" CONCAT "GetSlotNameForScheduleWaterUser"( STRINGIFY diversion ) [date];

      ENDFOREACH;

      ENDFOREACH;

    END;

    RULE                 "Set Normal Year Flag";
    DESCRIPTION          "This rule sets a flag to 1 if the year is determined to be Normal, i.e. not a Shortage or Surplus. This flag is used to determine whether or not proposed ICS activity may occur.";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January 31, Current Year" AND "NotSurplusOrShortageYear"(  );
    BEGIN

      $ "Mead Bank.Normal Year" [@"24:00:00 December 31, Current Year"] := 1.00000000;

    END;

    RULE                 "Set Surplus Condtions Flag";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January Max DayOfMonth, Current Year";
    BEGIN

      $ "SummaryOutputData.LBSurplusConditions" [@"24:00:00 December Max DayOfMonth, Current Year"] := IF ( ( $ "Mead.Pool Elevation" [@"24:00:00 December 31, Previous Year"] >= $ "Surplus Triggers.7 State Plan Level 2" [@"24:00:00 December 31, Previous Year"] ) OR $ "Surplus.SurplusRelease" [] > 0.00000000 "acre-feet" )
   THEN
      1.00000000
   ELSE
      0.00000000
   ENDIF;

    END;

    RULE                 "Set Shortage Condtions Flag";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January Max DayOfMonth, Current Year";
    BEGIN

      $ "SummaryOutputData.LBShortageConditions" [@"24:00:00 December Max DayOfMonth, Current Year"] := IF ( "IsShortageFromInput"(  ) )
   THEN
      1.00000000
   ELSE
      0.00000000
   ENDIF;

    END;

    RULE                 "Set ICS Put and Take Dates";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == "RunStartDate"(  );
    BEGIN

      FOREACH (DATETIME year IN "GetDates"( @"24:00:00 December Max DayOfMonth, Current Year", "RunEndDate"(  ), "1 years" )) DO
            $ "Mead Bank.LastYearForPuts" [year] := "DateToNumber"( @"24:00:00 December Max DayOfMonth, 2060" );

            $ "Mead Bank.LastYearForTakes" [year] := "DateToNumber"( @"24:00:00 December Max DayOfMonth, 2070" );

            $ "California ICS.StartBrockAndYDPTakes" [year] := "DateToNumber"( @"24:00:00 January Max DayOfMonth, 2041" );

            $ "California ICS.MWDICSStep1PutEndDate" [year] := "DateToNumber"( @"24:00:00 December Max DayOfMonth, 2040" );

            $ "California ICS.MWDICSStep1TakeEndDate" [year] := "DateToNumber"( @"24:00:00 December Max DayOfMonth, 2040" );

            $ "California ICS.MWDICSStep2EndDate" [year] := "DateToNumber"( @"24:00:00 December Max DayOfMonth, 2060" );

      ENDFOREACH;

    END;

  END;

  POLICY_GROUP   "Upper Colorado Priority Deliveries";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  BEGIN

    RULE                 "Short Users Above Grand Valley";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Short Users Above Grand Valley" );
    BEGIN

      IF_STATEMENT ("Floor"( $ "SeniorAgUsesBelowCameo.Total Depletion Shortage" [], 1.00000000 "acre-ft/month" ) > 0.00000000 "acre-ft/month") THEN
            FOREACH (OBJECT user IN "ListSubbasin"( "Users Above Grand Valley" )) DO
            IF_STATEMENT (user & "Depletion Requested" [] > 0.00000000 "acre-ft/month") THEN
            user & "Depletion Requested" [] := ( user & "Depletion Requested" [] - user & "Depletion Shortage" [] ) - "GetShortageAboveGrandValley"(  ) * ( ( user & "Depletion Requested" [] - user & "Depletion Shortage" [] ) / "ActualDepletionAboveGrandValley"(  ) );

            user & "Diversion Requested" [] := ( ( user & "Depletion Requested" [] - user & "Depletion Shortage" [] ) - "GetShortageAboveGrandValley"(  ) * ( ( user & "Depletion Requested" [] - user & "Depletion Shortage" [] ) / "ActualDepletionAboveGrandValley"(  ) ) ) * ( user & "Diversion Requested" [] / user & "Depletion Requested" [] );

      END_IF_STATEMENT;

      ENDFOREACH;

      END_IF_STATEMENT;

    END;

    RULE                 "Short Users Above Shoshone";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "Short Users Above Shoshone" );
    BEGIN

      IF_STATEMENT ("Floor"( $ "ShoshonePower.Total Diversion Requested" [] - $ "ShoshonePower.Total Diversion" [], 1.00000000 "acre-ft/month" ) > 0.00000000 "acre-ft/month") THEN
            FOREACH (OBJECT user IN "ListSubbasin"( "Users Above Shoshone" )) DO
            IF_STATEMENT (user & "Depletion Requested" [] > 0.00000000 "acre-ft/month") THEN
            user & "Depletion Requested" [] := ( user & "Depletion Requested" [] - user & "Depletion Shortage" [] ) - "GetShortageAboveShoshone"(  ) * ( ( user & "Depletion Requested" [] - user & "Depletion Shortage" [] ) / "ActualDepletionAboveShoshone"(  ) );

            user & "Diversion Requested" [] := ( ( user & "Depletion Requested" [] - user & "Depletion Shortage" [] ) - "GetShortageAboveShoshone"(  ) * ( ( user & "Depletion Requested" [] - user & "Depletion Shortage" [] ) / "ActualDepletionAboveShoshone"(  ) ) ) * ( user & "Diversion Requested" [] / user & "Depletion Requested" [] );

      END_IF_STATEMENT;

      ENDFOREACH;

      END_IF_STATEMENT;

    END;

  END;

  POLICY_GROUP   "Limit Demands";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  BEGIN

    RULE                 "Limit New Mexico to Apportionment";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND NOT "HasRuleFiredSuccessfully"( "Limit New Mexico to Apportionment" );
    BEGIN

      IF_STATEMENT ($ "Computed State Depletions.New Mexico Annual Normal" [@"24:00:00 December Max DayOfMonth, Current Year"] + $ "NavajoData.ScheduledNavajoEvaporation" [@"24:00:00 December Max DayOfMonth, Current Year"] > $ "Computed State Depletions.NewMexicoApportionment" []) THEN
            FOREACH (DATETIME month IN @"t" TO @"t + 11") DO
          DESCRIPTION          "Will limit NM to apportionment by reducing NavajoIndianIrrigationProjectNIIPandExports:AdditionalExports";
      $ "NavajoIndianIrrigationProjectNIIPandExports:AdditionalExports.Depletion Requested" [month] := "ComputeNMReductionPercentage"(  ) * $ "NM Schedules.NavajoIndianIrrigationProjectNIIPandExports_AdditionalExports_Depletion Requested" [month];

            $ "NavajoIndianIrrigationProjectNIIPandExports:AdditionalExports.Diversion Requested" [month] := "ComputeNMReductionPercentage"(  ) * $ "NM Schedules.NavajoIndianIrrigationProjectNIIPandExports_AdditionalExports_Diversion Requested" [month];

      ENDFOREACH;

      END_IF_STATEMENT;

    END;

    RULE                 "Limit Arizona Upper Basin to Apportionment";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND NOT "HasRuleFiredSuccessfully"( "Limit Arizona Upper Basin to Apportionment" );
    BEGIN

      IF_STATEMENT ("Floor"( $ "Computed State Depletions.Arizona Upper Basin Annual Normal" [@"24:00:00 December Max DayOfMonth, Current Year"], 1.00000000 "acre-ft" ) > $ "Computed State Depletions.ArizonaUBApportionment" []) THEN
            FOREACH (DATETIME month IN @"t" TO @"t + 11") DO
          DESCRIPTION          "Will limit AZ to apportionment by reducing ArizonaMiscUses:AZUBNavajoClaims<br>";
      $ "ArizonaMiscUses:AZUBNavajoClaims.Depletion Requested" [month] := "ComputeAZUBReductionPercentage"(  ) * $ "AZ UB Schedules.ArizonaMiscUses_AZUBNavajoClaims_Depletion Requested" [month];

            $ "ArizonaMiscUses:AZUBNavajoClaims.Diversion Requested" [month] := "ComputeAZUBReductionPercentage"(  ) * $ "AZ UB Schedules.ArizonaMiscUses_AZUBNavajoClaims_Diversion Requested" [month];

      ENDFOREACH;

      END_IF_STATEMENT;

    END;

  END;

END
